### A Pluto.jl notebook ###
# v0.19.27

using Markdown
using InteractiveUtils

# This Pluto notebook uses @bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of @bind gives bound variables a default value (instead of an error).
macro bind(def, element)
    quote
        local iv = try Base.loaded_modules[Base.PkgId(Base.UUID("6e696c72-6542-2067-7265-42206c756150"), "AbstractPlutoDingetjes")].Bonds.initial_value catch; b -> missing; end
        local el = $(esc(element))
        global $(esc(def)) = Core.applicable(Base.get, el) ? Base.get(el) : iv(el)
        el
    end
end

# ╔═╡ 67019338-dca4-4fe1-8a7c-55cf5b929486
begin
using PlutoUI,Kroki
include("funs.jl");# 加入通用函数
PlutoUI.TableOfContents(title = "目录", indent = true, depth = 4, aside = true)
end

# ╔═╡ 5a64e73d-d7b8-4fa3-b81a-3154ae5a122b
 html"<font size=\"80\">实验1 Julia安装与入门</font>"

# ╔═╡ dc1a4db7-a9fd-49dd-b135-10c7099463b6
md"""
**目的与要求**
1. 掌握Julia软件的安装与基本使用
2. 掌握Pluto的安装与使用
3. 掌握Julia语言的基础语法
""" |> fenge

# ╔═╡ cfb64224-5ef7-4300-a6e0-f38ad8e68cac
md"""
# ===第一部分 软件安装===
"""

# ╔═╡ ec6b4326-88a1-4375-a828-3e28ca7b2063
md"""
## 安装REPL环境
虽然是编译型的语言， 但Julia语言提供了一个类似R语言的控制台。 其安装过程非常简单， 只需按照如下步骤依次操作即可。

1. 请根据自己的电脑系统， 到[**Julia官网**](https://julialang.org/downloads/)下载最新版本的相应软件。下面假定是windows系统。

2. 双击下载的exe文件，选择安装路径（或者采用默认的安装路径），其余都是默认就行。

3. 安装成功之后，桌面上会出现Julia图标。
5. 双击图标打开Julia控制台， 通常叫做**REPL环境**。REPL是“Read–Eval–Print Loop”(读取-求值-打印-循环)的缩写,是一种简单的、交互式的编程环境。

下面是一个打开的REPL环境的图片。 图中的 `julia>` 提示当前是Julia语句的输入模式， 在该模式下， 在光标处输入语句，回车之后就可以看到语句执行的结果。

"""

# ╔═╡ 02124a75-a225-4b7d-9b11-f22c5022a9a5
LocalResource("img/repl.png")

# ╔═╡ 4edc479e-ea0e-4e87-975b-35ac93cc6314
md"""
## 安装Pluto包
Pluto是一个基于Julia的科学计算环境， 类似Jupyte notebook， 但存在一些设计上的显著差异。 本教程关于Julia的操作都在Pluto中完成。 下面介绍如何安装Pluto环境， 具体可以参考下面的视频。

Pluto是一个Julia的包（package）， 其安装只需要
1. 在REPL环境中， 将REPL切换到包安装模式（在Julia模式下，输入**英文状态**的右中括号 ]。）
2. 在包模式下（提示符： `(@v1.9) pkg>`, 不同版本会稍有不同），执行`add Pluto`就可以了（你的安装信息可能跟视频中的不同， 视频中是因为已经安装了）。
3. 安装完成之后， 通过输入删除符号（Backspace）切换到Julia语句模式下， 通过执行
```julia
using Pluto
Pluto.run()
```
两条语句即可启动Pluto环境。默认情况下，Pluto会打开一个网页。
"""

# ╔═╡ ead4250b-1d7b-4934-ba49-2d8aa54dd15e
LocalResource("video/pluto安装.mp4", :width => 800)

# ╔═╡ aaafcdbe-a5e4-44da-bb6b-6a2d08c61602
md"""
## Pluto的使用
由于Pluto是本教程的关键计算环境， 下面的视频简要介绍了一下Pluto的使用。 更多使用的方法， 可以参考Pluto提供的官方notebook。
"""

# ╔═╡ 7a51fae3-cf99-41d9-834d-add84db94038
LocalResource("video/Pluto写代码.mp4", :width => 800)

# ╔═╡ 51f50e0a-e271-4448-b054-4c813dd2f55f
md"""
# ===第二部分 Julia入门===
"""

# ╔═╡ 6a64ae31-96b9-4eeb-a696-23859c898481
md"""
# 1 概述
"""

# ╔═╡ f0e96543-bbd5-4095-89e4-e11f510c2d12
md"""
该教程粗略的摘录了 Julia 的基本语法，不熟悉 Julia 的同学可以先粗略地通读该教程，以大致熟悉基本操作。

如果想要了解详细内容可以查阅[官方文档](https://docs.julialang.org/en/v1/)。

如果想比较全面的学一下Julia, 可以看看Github上面的这种本[Julia编程基础](https://github.com/hyper0x/JuliaBasics/tree/master/book)
"""

# ╔═╡ 284d7a22-69b2-4bbb-95c0-c6c7ec32a57f
md"""
**程序 = 数据结构+算法**， 要学会编程， 你需要知道一些基本的数据结构（类型）以及如何去操作这些数据（算法）。 数据结构可以理解为数据的组织方式。

数据保存在内存中， 为了操作特定的数据， 我们通常需要给数据取一个名字--变量名。
"""

# ╔═╡ 6dca7f64-0e82-4e75-91f3-b72dc85461cf
md"""
# 2 数据结构
"""

# ╔═╡ 167ee46b-e00f-406a-aa9e-b0d932641611
md"""
## 2.1 变量与值
在Julia中，变量是与值关联(或绑定)的名称。当您想要存储一个值时，它很有用(例如，你经过一些数学运算后得到的)以备以后使用。 通常， 我们会用**赋值操作符（=）**实现将一个值和对应的变量名关联起来 （也就是赋值的时候，实现变量的定义）。如`x=3`， 表示把数字3跟变量x绑定起来。 赋值操作符在很多语言中都是类似的。


例如:
```julia
	# 把数值10分配给变量x， 或者说， 变量x绑定数值10
	julia> x = 10
	10
	# 用变量x绑定的数字做运算
	julia> x + 1
	11
	# 重新绑定x的值为一个表达式运算的结果
	julia> x = 1 + 1
	2
	# 也可以把变量x绑定到其他的数据类型上去（比如字符串）
	julia> x = "Hello World!"
	"Hello World!"
```
"""

# ╔═╡ 0185a035-5e64-42e8-bec1-91c1aeab460f
md"""
### 值
在Julia中， 值具有的一个有别Python的重要特点是具有类型（存储类型）。 比如一个数字， 可能是整型， 浮点型， 等等。 使用`typeof`可以查看一个值， 或者一个变量绑定的值的类型。
"""

# ╔═╡ dad48233-c0ab-475d-9ba9-d7e4038df471
x = 1

# ╔═╡ a4016cf3-6269-44c3-a1c6-5b513c4c3740
typeof(x)

# ╔═╡ 3438854f-f0b6-4508-bade-fa17f0bba636
typeof(1.0)

# ╔═╡ 62244b7c-adba-463b-9b58-a1359cfcceb8
md"""
类型具有层次结构， 可以使用supertype和subtypes获取一个类型的父类型和子类型。 类型的层次结构是Julia中非常重要基础设施， 是实现Julia函数多重分派的基础， 也是Julia效率较Python要高的重要原因。 比如， 数字类型（Number）， 在Julia中就有非常多的子类型。 
"""

# ╔═╡ d36f0906-2be1-400d-8167-616494e371db
function print_supertypes(T)
           println(T)
           T == Any || print_supertypes(supertype(T))
           return nothing
       end

# ╔═╡ 0a45f36b-1708-4043-a763-29b2ae7b93a0
print_supertypes(Int64)

# ╔═╡ 7a279bb7-283b-493c-b263-d15871fd1e6c
function print_subtypes(T, indent_level=0)
          println(" " ^ indent_level, T)
          for S in subtypes(T)
              print_subtypes(S, indent_level + 2)
          end
          return nothing
      end

# ╔═╡ 50aba0f6-1cbe-478d-b2db-b0aaf102f31c
print_subtypes(Number, 4)

# ╔═╡ bf4cc08f-e9ba-460e-bf86-e6e0f064fecb
md"""
### 变量名命名规则
"""

# ╔═╡ 36ce4558-39b7-4c2e-9e78-4f0ecbdfae41
md"""
你可以把变量看成是**盒子**的名字。 这个盒子（内存中的某个区域）里面可以装各种类型的数据。比如， x = 10， 就可以看成是名叫x的盒子， 里面装的是数字10。 很多语言要求变量名只能是字母数字下划线构成， 在julia中，你可以使用**几乎所有可能的符号做变量名（变量名必须以字母(A-Z或a-z)、下划线或大于00A0的Unicode码点子集开头）**。其后可以跟几乎所有的字符， 参考[这里的解释](https://docs.julialang.org/en/v1/manual/variables/#man-allowed-variable-names)。 尤其是以惊叹号！结尾的函数名， 表示该函数会修改参数的值。
"""

# ╔═╡ 03901eec-aa18-48b2-a807-7a7551e6268f
中国 = 100

# ╔═╡ a0cdaed9-868c-4619-9ee5-665ee6f69686
中国

# ╔═╡ 0ab3c5e9-3767-404b-a361-7f194e740be3
美国=80

# ╔═╡ 2dc076e1-9d5a-4d6f-ad52-78f3c60a5a58
中国 - 美国

# ╔═╡ b38e185e-c64e-4c26-9e58-c9ad2dec3969
π = "你好"

# ╔═╡ e7a3a4f8-90ae-4bc8-b0fa-d5cb9b0ba3f2
α = 10

# ╔═╡ 1c9c20ed-38a4-47bd-a868-e64ff36101cc
α

# ╔═╡ 764b9285-bc9a-4b13-a652-e7646a1320df
α

# ╔═╡ 9cbd6def-d1e9-406e-a6db-5baecc535537
⬠ = "五边形"

# ╔═╡ 5defb84a-0fe2-4972-8dd5-f0430426b4b4
π * ⬠

# ╔═╡ 41d41291-4334-43c3-b596-a09433cd0018
md"""
注意， 写法`a=b=value`表示变量a，b绑定到了同一个值， 值都是value。如果value是一个可变结构，比如数组， 那么改变value的值， 通过a改变value的值， 会导致b也发生改变， 因为a，b本质上指向同一个对象， 只是名字不同而已。

如果， 再次写`b=value1`， 这时候， b绑定到了一个新的值，a绑定关系没变。
""" |> danger

# ╔═╡ 2d963618-f5b5-47f1-85bc-832bbbc29e5b
md"""
## 2.2 基础数据类型
这里总结一些基础的数据类型， 主要有数值类型， 字符和字符串类型， 字典与集合， 数组等几种常见的类型。Julia的优势之一就是它强大的类型系统。 在Julia中，任何数据都是有类型的， 就像C/C++等语言， 从而可以使代码运算速度加快。 学过C/C++等的同学可能对编程过程中要注意类型很头痛，这也正是Python等脚本语言隐藏类型的原因。 可喜的是， Julia也可以不指定数据类型， 这时候， 要么系统能自动推断你的数据类型， 要么它会给数据一个默认的数据类型（Any类型）， 这让Julia写起来， 又有点像R和Python。 这一特性， 让Julia既有能力获得C++的速度， 也可以像Python一样方便。虽然我们可以不指定数据类型， 但知道一些基本的常识，有利于我们写出高性能的代码和读懂别人写的代码。因此， 下面过一下基本的一些数据类型。 参考[Julia编程基础第五章](https://github.com/hyper0x/JuliaBasics/blob/master/book/ch05.md)
"""

# ╔═╡ 7fc75f1d-d3c4-435d-a6d3-9a9f453e999c
md"""
### 数值类型
数字是我们从小的开始学习的概念， 从最开始的整数到，有理数， 实数， 复数， 我们接触了各种数值的概念。 在程序语言中， 数值是通常最简单、最基础的数据类型。有些语言不关注数据的具体类型， 都统一视为“数字”。 但强于科学计算的Julia语言， 有丰富的数值类型， 罗列部分如下：

		- 布尔类型：Bool
		- 有符号整数类型： BigInt、Int8、Int16、Int32、Int64和Int128
		- 无符号整数类型： UInt8、UInt16、UInt32、UInt64和UInt128
		- 浮点数类型： BigFloat、Float16、Float32和Float64
将数值细分为不同的类型是有意义的， 不仅能减少数据的存储空间， 还可以提高数据的计算效率。 当然， 如果你觉得处理这么多数据类型很麻烦， 你也可以不管数据类型。 Julia会自动选择默认的数据类型。 比如， 通常整数会当成Int64的类型（在64位的机器里）， 而带了小数点的有理数会当成Float64类型。
"""

# ╔═╡ e635ce57-29b9-4164-881b-132f41e3b6ba
md"""
下面的代码显示整数默认是Int64类型， 实际上， 因为我的电脑是64位， 所以显示是Int64， 如果是32位的机器上，下面的结果会是Int32.
"""

# ╔═╡ 1a1880ca-f9d5-45df-a8c7-65026c990962
typeof(10), typeof(10.5)

# ╔═╡ 04ce6f55-1b44-4457-9b2a-f55383e83acd
md"""
#### 类型转化
如果你需要的是某种特定的类型，可以采用如下方式获得。
- **类型名（数字或数字变量）**
- **变量::类型名 = 数字**
"""

# ╔═╡ d167a9f6-57e1-4b11-98dd-e4eede5b665d
typeof(Int8(32))

# ╔═╡ 5eb5333e-e4bc-4839-b0dd-1070b37f7994
xm::Int16 = 3; 

# ╔═╡ dfb6421a-ac7f-444b-ad5d-061a45e573ac
typeof(xm)

# ╔═╡ dfce6ede-7cf7-4e1a-9442-bc112e618f95
typeof(Int32(xm))

# ╔═╡ 8f5cfec9-5c67-4c72-86f0-1ec62215e924
md"""
上面的两个冒号::表示类型注释符， 用于告诉系统左边的变量类型是双冒号之后的类型。
"""

# ╔═╡ f344e8fa-67cd-411e-9a75-5d5406bb3ff9
md"""
#### 正负无穷大与不存在（Inf*, NaN*）
Inf*表示无穷大（*表示宽度）， NaN*表示不是数（Not a Number）， 参考下面的例子。
"""

# ╔═╡ e2513772-84f0-4bcc-b234-fb30054e1dd5
typemax(Int64), typemax(Float64), 1/0, 0 * Inf

# ╔═╡ a4d6c456-6820-40d0-afaf-fe4abae93e0e
md"""
### 字符与字符串
Julia支持Unicode编码， 单个的字符用**单引号**包裹。 字符串用**双引号**包裹，  也可以用三联双引号， 通常用于文档中。比如这个cell的输入值。 字符的类型是Char， 字符串的类型是String。
"""

# ╔═╡ 1ec55ebc-5848-40bd-b78f-0dd8afc0ce5b
typeof('我'), typeof('a'), typeof("我爱Julia编程")

# ╔═╡ 83393a23-3579-4cd4-af61-729c6d018074
md"""
#### 字符串的常用操作
- `sizeof` 获取字符串（任何对象都可以）占用的字节数。
- `length` 获取字符串的字符数量。
- `*` 字符串拼接， 也可以使用`string`函数。
- [i] 字符串索引(获取第i个字符）， 不过请注意Unicode字符串索引可能引发的问题。
- [i:j] 字符串截取（获取索引号从i到j的所有字符）。
- `$(var)` 用变量var的值插入字符串中。
- **搜索**。 `findfirst`, `findlast`, 请使用`@doc 函数名` 的方式获取其使用方法。
- occursin, contains 判断一个字符串是否包含某个子串（或模式）
- startswith， endswith 判断字符串是否以某个子串开头或结尾
- first, last 获取字符串前面或结尾的n个字符。
"""

# ╔═╡ ad929880-e25e-4f0e-8d51-ec5eda953abe
length("我爱Julia！")

# ╔═╡ b81e2c42-8b7e-4487-8c76-d35d023c2a13
"good" * "morning"

# ╔═╡ fad5f0b9-da41-4123-bb91-51500a57dea5
md"""
字符串在数据分析中一种常用应用是： 我们读取的数据可能是字符串格式， 需要将其转换为数字。常使用的函数是`parse(type, str)`， 这个函数通常用于类型之间的转换。
"""

# ╔═╡ 708409ac-1f07-481d-ac95-2f028b6d5e80
id = "352719200008101112"

# ╔═╡ 4ad0d0de-7e57-46cc-b9a4-9b07802d997c
id[1:2]

# ╔═╡ 1354e9d3-206c-4355-9641-45bf3cd179ff
id[11:12]

# ╔═╡ 69585cb2-a403-49bf-b0d8-36eb347bfaeb
parse(Int64,id[11:12])

# ╔═╡ c6567c1b-00fc-4c35-81a1-1b92545ad749
parse(Float64, "33222.45")

# ╔═╡ 5702cfab-7d96-482b-8c5a-cf35c045e18c
str = "我爱julia！"

# ╔═╡ 2f8b1912-1cf9-4ef7-95e3-0e795f89c271
length(str)

# ╔═╡ f7113d25-6b70-495c-a04d-0e984fdda75a
md"""
有时候， 我们可能会看到字符串插值， 也就是把一个变量的值插入到另一个字符串中。这可以通过**\$(变量名)**实现, 括号不是必须得， 只有当变量名容易与周边的字符混淆时使用。

你可以在下面的文本框中输入任何名字， 观察下面一行文本的变化。 `@bind name TextField(default="不告诉你")`, 注意， 这一行代码只是把你输入的内容，TextField的值，绑定@bind到了一个变量name。 如果你想了解更多这种UI项目， 可以参考Pluto的主界面上的介绍。 
"""

# ╔═╡ 0d40730c-2b65-4ef9-86bf-38a80f36e999
@bind name TextField(default="不告诉你")

# ╔═╡ 0d5704c1-932d-429c-b983-22dcfb9dc2b0
"我的名字叫：$name"

# ╔═╡ b8c1a101-2ce0-4fcc-b483-e9a94256355a
sizeof(str)

# ╔═╡ 203ba3c8-5d20-4c2c-998d-99ed25b77bfa
contains("JuliaLang is pretty cool!", "Julia")

# ╔═╡ 39b7138b-e0ac-4512-951e-f3da0596aae9
md"""
### 符号Symbol
在已解析的julia代码中用于表示标识符的对象类型。也经常用作标识实体的名称或标签(例如，作为字典键)。可以使用:操作符构建。 

符号跟变量名是不同的东西。变量名绑定了值。访问变量名就是访问相应的值。而符号代表的是被解析的代码（抽象语法树）中的标识符。通过对表达式求值eval，可以获得对应的值。 每一个变量名都会有一个对应的symbol, 但Symbol不一定是变量。比如一个字典变量中的键。

**千万不要混淆Symbol和字符串。**
"""

# ╔═╡ 4e6c71be-0777-4994-b46f-2e8ad85dd00f
:name 

# ╔═╡ 380893cf-d028-49a0-8541-0c375b2d9b6f
typeof(:name)

# ╔═╡ 62f4f0c5-5dd4-4f57-85ae-c5e5eb02a5bc
typeof("name")

# ╔═╡ 23015434-367f-468d-92e8-c6ba22830d67
xs = 3

# ╔═╡ 30a728de-27e5-43f8-999d-c450e941ef2b
eval(:xs)

# ╔═╡ 35fbe418-4bd5-4dee-a98d-9e976a8cb3d9
md"""
## 2.3 运算符
这里主要是总结一下Julia中的常见操作符，也称运算符（Operator）。 Julia中的运操作符是用于对变量和值执行操作的数学符号， 这些符号通常用来进行算术和逻辑计算。 操作符对其执行操作的变量称为操作数(Operands)。 比如，在表达式
`a + b` 中， a和b就是操作数，而 `+` 就是操作符。 作为入门和基础的应用， 需要我们掌握以下四种运算符： 

- 算术运算符  
- 逻辑运算符  
- 赋值操作符  
- 矢量化的点操作符  
- 比较运算符  


可参考这篇[文章](https://www.geeksforgeeks.org/operators-in-julia/)获取更多的细节描述。
"""

# ╔═╡ 292223b0-0549-47d5-9c13-55e4bca029e2
md"""
### 算术运算符
算术运算符是一门语言中常见的， 主要包括 + - * /等。

|运算符| 含义 | 用法|
|-----|------|-----|
| + | 求和  | a + b |
| - | 求差  | a - b |
| * | 乘法  | a * b |
| / | 除法  | a / b |
| \ | 除法  | a \ b (等价于 b / a) |
| $\div$ | 整除 | a $\div$ b|
| % | 求余数 | a % b|
| ^ | 乘方  | a ^ b|

注意， + - 也可以用作一元运算符， 在变量前添加 + ， 不会改变变量值； 添加 - ， 会将变量变相反数。 上面的$\div$在编辑器中可以通过 \div+[TAB] 键输入。 这也是Julia特殊的地方， 它是完全支持Unicode字符的， 所以我们可以使用类似于数学书写的方式去写各种变量。 以后看到类似的数学符号， 他们都是通过相应的latex符号+ TAB键打印出来的。 你也可以通过复制一个符号， 然后用 `? 符号`的方式在REPL中获得其书写方法帮助， 或者用`@doc 符号`的方式获得相关符号的帮助文档。下面演示的是整除。
下面是一些例子：
"""

# ╔═╡ 379db06c-a811-4894-9414-4ebeefa90b11
😂 = 35

# ╔═╡ 75b9042b-d15a-43fe-8651-f5ef2ea083a0
😂

# ╔═╡ f699b11c-6d47-4c18-9fef-3136467a090c
7 ÷ 3

# ╔═╡ 8acfc20e-2d57-4cc6-a24e-42fa8acf012a
# @doc ÷

# ╔═╡ 5839e72e-8771-4184-a065-2196ba60b2f4
2^3

# ╔═╡ 0b6940b5-9d5e-439d-a974-fa056ee1ad2e
 # 定义变量， 你也可以改变这里的定义, 一次给多个变量赋值， 跟Python类似
a, b = 9, 4

# ╔═╡ 4e8df286-dfb2-4693-9261-64a9bcc9d002
(a + b, a - b, a * b, a / b, a \ b, a \ b == b / a, a ÷ b, a % b, +a, -b)

# ╔═╡ 7019a3b5-f0cb-40fa-8e66-51055af971e8
md"""
每一个算术运算都可以跟赋值符号=结合在一起形成一个更新运算。
+=  -=  *=  /=  \=  ÷=  %=  ^=

比如：
```julia
a += b
```
表示：
```julia
a = a + b
```
一般而言， 一个更新运算表示把左操作数与右操作数做相应运算的结果再赋值给左操作数。
""" |> zy

# ╔═╡ 4e544be5-4a04-4182-a58e-13bdcd6c517e
md"""
### 比较运算
比较运算主要用于对变量的大小比较，主要有大于、小于、等于，以及衍生的大于等于、小于等于、不等于等6种情况， 比较的结果通常是逻辑值 true 或 false， 常用于 if 语句等逻辑判断场景。 下面是具体用法：

|运算符| 含义 | 用法|
|-----|------|-----|
|>	| 大于: 左操作数大于右操作数时为 true	| x > y |
|<	| 小于: 左操作数小于右操作数时为 true	| x < y |
|==	| 等于： 左操作数等于右操作数时为 true    | x == y |
|!=, ≠	| 不等于： 左操作数不等于右操作数时为 true 	| x != y or x ≠ y |
|>=, ≥	| 大于或等于: 左操作数大于或等于右操作数时为 true	| x >= y or x ≥ y |
|<=, ≤	| 小于或等于: 左操作数小于或等于右操作数时为 true	| x <= y or x ≤ y |

注意， 上面几个特殊符号对应的latex代码≠ （\ne）, ≥ (\geq), ≤ (\leq) 。 
下面是几个例子：

"""

# ╔═╡ b1d9c45b-3a31-4029-895c-427d44d44d40
4 ≠ 4

# ╔═╡ f12ade36-ff61-435b-9a76-e9f739fe79ce
a > b, a < b, a == b, a != b, a >= b, a <= b

# ╔═╡ d5b8e5de-f040-408c-92ac-aed3c3dffe51
md"""
### 逻辑运算符
逻辑运算符主要用于构造复合条件， 多用于程序流程控制。 主要是三种： 与（and）, 或（or）, 非（not）。 具体用法如下：

|运算符| 含义 | 用法|
|---|---|---|
| &&	| 与: 当且仅当两个操作数都是 true 时， 结果为true	| x && y|
|  \|\|	|或： 当至少有一个操作数为true时， 结果为true |	x \|\| y | 
| !	| 非： 将true变为false， false变为true | !x |

下面是几个例子， 其中`isodd`, `iseven`分别用于判断一个数是奇数和偶数。
"""

# ╔═╡ 28a8e5e5-d904-4888-b36b-13c0aad8f3a1
a, b

# ╔═╡ 3540f431-7b50-4ed1-9d66-3cb4568856a2
isodd(a), iseven(b), isodd(a) && isodd(b), isodd(a) || isodd(b), !isodd(a)

# ╔═╡ 5912b3ca-a74b-4174-859c-ed5b4cd669d5
md"""
### 常用数学函数
Julia 预定义了非常丰富的数学函数。一些常用的函数如下：

- 数值类型转换： 主要有T(x)和convert(T, x)。其中，T代表目的类型，x代表源值。
- 数值特殊性判断： 有isequal、isfinite、isinf和isnan。
- 舍入： 有四舍五入的round、向正无穷舍入的ceil、向负无穷舍入的floor，以及总是向0舍入的trunc。
- 绝对值获取： 用于获取绝对值的函数是abs(x)。一个相关的函数是，用于求平方的abs2(x)。
- 求根： 函数sqrt(x)用于求取x的平方根，而函数cbrt(x)则用于求取x的立方根。
- 求指数： 函数exp(x)会求取x的自然指数。另外还有expm1(x)，为接近0的x计算exp(x)-1。
- 求对数： log(x)会求取x的自然对数，log(b, x)会求以b为底的x的对数，而log2(x)和log10(x)则会分别以2和10为底求对数。另外还有log1p(x)，为接近0的x计算log(1+x)。

除了以上函数之外，Julia 的Base包中还定义了很多三角函数和双曲函数，比如sin、cos、atanh、acoth等等。另外，在SpecialFunctions.jl包里还有许多特殊的数学函数。不过这个包就需要我们手动下载了。

通常可以用`@doc 函数名`获取一个函数的帮助文档。
"""


# ╔═╡ d74a2fae-422d-4f9d-be03-d438535e2a70
ceil(5.6), floor(5.6)

# ╔═╡ e31f1c0c-a914-432e-b20a-6cee84852400
abs2(-5)

# ╔═╡ f92faad9-15f5-4a2a-951d-42a4b2744e4e
convert(Int64,10.0)

# ╔═╡ cc6f8d8b-fa94-418c-9b1b-11d517e5bb8c
ceil(4.5)

# ╔═╡ c0764726-337c-4c9c-b0bc-235cca726051
floor(4.5)

# ╔═╡ 27e2d30c-96bb-4a28-ba47-6ea7d9bb3b2d
md"""
### 矢量化的点操作符
点操作符是Julia中实现向量化运算的关键操作符。在R、Python等语言中， 许多运算默认都是向量化的。 但在Julia中， 情况有所不同。 在Julia中， 只要在一个运算的前面加上一个点， 这个运算就变成了向量化的了。 即这个运算会作用到运算对象的每一个元素上。 
"""

# ╔═╡ 88e526c6-cd09-4a75-9bc0-cec5a7a80234
v1 = [1,2,3]; v2 = [4,5,6];

# ╔═╡ a89c40a4-4d12-4fc5-8cb9-75a8e2c9f708
v1 .* v2

# ╔═╡ ff6530fa-8b79-4321-bde4-d42f3de138c5
v1.^2

# ╔═╡ a779ef7b-f4ff-4d01-9f69-6e04d4e224a9
v1 .* v2

# ╔═╡ 439256c1-652c-4296-86b0-9cf3f810f9f6
md"""
### 向量化代码
在Python、R等语言中， 为了写出更高效的代码， 一般都尽量使得代码是向量化的。一个函数``f(x)``施加到向量``v``上时，默认会施加到向量中的每一个元素上``f(v[i])``。在Julia中， 也支持向量化。只需要在函数调用的括号前面加一个点即可。例如
```julia
x = rand(10)
sin.(x)
```
可以实现对10个元素同时求正弦sin。 因为运算符也是函数， 所以运算符也可以是向量化的， 可以通过在运算符前加一个点让运算符变成向量化运算符。比如，下面的 **.^**可以实现对向量中的每一个元素求平方。

```julia
x = rand(10)
x.^2
```

多个函数同时向量化也是允许的， 而且在Julia中会比较快。 比如， 我们对一个向量中每一个元素平方之后，求正弦， 再求余弦， 那么可以这么写：

```julia
x = rand(10)
cos.(sin.(x.^2))
```
上面的代码中有三个点， 表明三个相关函数（^这个也是函数）都是向量化的。不过，如果有太多点运算， 可能代码看起来比较繁琐， 这时候可以使用宏`@.`。 宏有点像函数， 但不需要写括号。宏`@.`是告诉Julia， 这个宏后面的代码是向量化的， 只是不需要写点了。因此，上面的代码也可以写成：
```julia
x = rand(10)
@. cos(sin(x^2))
```
这时候， 如果你要告诉Julia， 其中的某个函数不是向量化的， 那么你需要在该函数名前加上美元\$符号。

例如`@. sqrt(abs($sort(v)))`表示对向量排序（sort）之后，再每个元素求绝对值（abs），然后再开方（sqrt）。

在julia中， 你直接写循环会比向量化代码更快， 所以不需要担心自己的代码不是向量化的。 我们还是会写向量化的代码是因为非常方便，仅此而已。
"""

# ╔═╡ d304524f-a6d8-4fe3-9a0c-aa55965f831f
md"""
## 2.4 元组
**元组(tuple)**是由括号和逗号构建的不可变对象，其中元素可以是任意类型：
```julia
(e1,e2,e3,...)
```
元组的类型是：`Tuple{e1的类型, e2的类型， ...}`

在需要函数返回多个值时，我们通常将值用逗号分隔， 返回的结果就是一个多个值构成的元组。 

元组可以用位置索引。
"""

# ╔═╡ b21dedc7-23a2-4e79-84fc-943dd3053fab
t = "ok",15

# ╔═╡ edd18731-64ee-4924-925f-c723ed9ab7ec
typeof(t)

# ╔═╡ 718f6f4a-f337-4cb3-a9f1-e90a32411d8e
t[2]

# ╔═╡ a055cb83-9e64-415a-bd1a-cfa4a2b5b7dc
length(t)

# ╔═╡ 8e01e846-b392-4610-8be1-e15485a74eaf
md"""
**命名元组(NamedTuple)**
命名元组中的“命名”并不是说元组有名字，而是说其中的每一个元素值都拥有自己的名字。例如：
"""

# ╔═╡ 0a4a689d-5a4e-4d5e-a278-beb137a80ac6
student1 = (name="Robert", reg_year=2020, 性别='男')

# ╔═╡ 18cae4b0-0b2a-407a-b8c6-236a631a84a7
typeof(student1)

# ╔═╡ a1d25013-d982-438b-a9be-cb8f2a651a8a
md"""
相对于普通元组， 命名元组的好处是， 提供了一种访问元组元素的新的方式，即  **元组名.元素名**
"""

# ╔═╡ e442bb4c-4470-4415-9247-caffda420bf5
student1.name

# ╔═╡ 7be99f73-40bf-4717-b64b-b4b0e850c364
student1[2]

# ╔═╡ 4ba402a6-2fbe-493d-8de8-266eace85a35
md"""
在构建命名元组时， 经常在括号的前面加上一个分号；， 这是为了避免元组只有一个元素时产生错误。没有分号， 一个元素放进括号还是这个元素， 并不会变成元组。

构建元组时， 最后一个元素后面加一个逗号，不会影响最终的结果。但如果整个元组只有一个元素， 这个逗号就必须要添加了。
""" |> attention

# ╔═╡ 17e4686d-f9a0-4201-baec-4cc1730b1821
(; xt=3)

# ╔═╡ 7d20bf88-7f1f-4159-88b3-c40d2e671781
(xt=3)

# ╔═╡ 9fa94e04-fdbb-4f05-af6b-9330b3f52ec4
(xt,)

# ╔═╡ 57a03ff9-6fa0-457c-88d4-898a6fde710c
(xt)

# ╔═╡ 1f03b743-60c7-45e1-bba0-1f008697a03e
md"""
## 2.5 Pair对象

用 推出符号 => 可以构建pair对象。 当然， 也可以用Pair构造： 
```julia
Pair(x, y)
x => y
```
一个pair对象包含一个first元素， 和second元素。 看上去有点像命名元组， 但在迭代时， 一个pair对象是一个整体。
"""

# ╔═╡ 1260013b-da66-439a-9a2b-76ccb7b4a132
p1 = "name"=>7

# ╔═╡ 065f15ad-1cbe-474e-901f-411aefb2e07f
p1.first

# ╔═╡ 6fa90f17-74c4-4ee7-9f1d-ac317c36100d
p1.second

# ╔═╡ cfab338f-19b1-4a26-b74c-ee630f4a3769
md"""
## 2.6 字典Dict
字典也是常用的数据结构。字典中有键-值对， 通过键可以方便的获得值。可以用键值对元组向量构建字典， 也可以用键值对Pair构建字典。

```julia
Dict([(key1, value1), (key2, value2),...])
Dict(key1=>value1, key2=>value2,...)
```
对于字典， 可以使用keys，values函数分别获取由key和value构成的可迭代集。

### 字典相关操作
- haskey(collection, key) -> Bool 判断是否存在某个key
- get(collection, key, default) 获取某个key的值， 如果不存在这个key，返回default。对于字典， 可以直接使用中括号给定的key的方式获取key对应的值，即 **D[key]**, 但如果key不存在， 这种操作方法会出错。
- get!(collection, key, default) 获取某个key的值， 如果不存在这个key， 增加key=>default对，返回default
- delete!(collection, key) 删掉给定的key， 如果存在的话，并返回collectio。
- pop!(collection, key[, default]) 删掉给定的Key， 返回对应的值， 如果key不存在，返回默认值default， 这时候不指定默认值会出错。
- merge(d::AbstractDict, others::AbstractDict...)合并两个字典， 如果字典中具有相同的key，最后的字典中的对应值会被保留。
"""

# ╔═╡ 269d7cff-d99e-4eb9-a573-c08b869463e7
D = Dict('a'=>2, 'b'=>3)

# ╔═╡ 33103b72-5f3b-4699-9649-9204361ee9d7
keys(D), values(D)

# ╔═╡ 6cc5ec16-ff84-44c6-a704-d3ab92b49cc1
haskey(D, 'a'), haskey(D, 'c')

# ╔═╡ dd807cf4-15cd-4d8f-816d-ffeb259953ae
D['a']

# ╔═╡ 5ccba59a-fec6-429e-8bf2-0445819ba1d2
get(D, 'a', 1), get(D, 'c', 1)

# ╔═╡ 3764bd78-069b-4c9d-bcbe-12f85da65d9c
md"""
## 2.7 集合set
Julia中实现了数学上集合的概念， 即集合包含的元素具有：互异性、无序性、确定性。集合常见的操作是：
- 判断元素是否在集合中（确定性） in
- 结合求并 union
- 求交 intersect
- 求差 setdiff
- 对称差 symdiff
具体请参考[集合相关文档](https://docs.julialang.org/en/v1/base/collections/#Set-Like-Collections)
"""

# ╔═╡ 9076e90c-472b-40a7-9399-61f61ca893ac
5 in Set([1,2,3])

# ╔═╡ ddb07406-e982-4829-9297-ed1427234ed0


# ╔═╡ f0868cfc-336a-403d-88b3-d6c0ad4b31f1


# ╔═╡ d3b4eb44-ff14-424d-b97c-53fc373ae03d
md"""
## 2.8 向量
向量数据分析中是非常常见的。 跟元组类似，向量也是一列数据。只不过， 向量中的元素是同一种类型。
### 向量的构造
构造向量非常简单， 只要用中括号(元组用的是小括号）和逗号(分号)即可。
```julia
[e1,e2,e3,...]
```
"""

# ╔═╡ 4803a865-00ad-4595-8d05-43aef456e398
[1, 2, 3]

# ╔═╡ 4ac509b2-61ca-401a-83db-9298537de7e1
[1;2;3]

# ╔═╡ 5f70b1ed-6f99-4997-aa37-0efd6b1b6249
md"""
向量的数据类型是`Vector{元素类型}`
"""

# ╔═╡ a386ef9e-674a-4d7a-8f55-6603070457c3
typeof([1, 2, 3])

# ╔═╡ 8d091301-85e9-46d5-a4ae-1aac98f1fedd
md"""
使用**collect函数**可以方便的把一个范围（range）里的所有元素提取到向量中
"""

# ╔═╡ ba6b772c-5691-4e48-8f37-972956cdee65
collect(1:10)

# ╔═╡ c05d7186-3761-4d86-be54-ccd0c8c58b5a
collect(range(1,10, 5))

# ╔═╡ dbace4f9-e018-4356-8ed3-e652c7f123b4
collect(range(1,10,2))

# ╔═╡ cd2211ae-5864-4e87-9293-3b4c81ef23b2
md"""
此外， 可以使用数组的构造函数。 比如 `Vector{Float32}(undef, 100)` 就是构造一个长度是100的未初始化的元素类型是Float32的向量（用`@doc Vector `可以查看帮助文档）（这时候可以用循环来实现数据构造）。 对于向量来说， 还可以用  **类型[]**的方式构造某种类型的向量, 但不能同时指定长度（这时候可以使用push!, append!添加元素）。 


"""

# ╔═╡ 524df39e-8200-4a53-b762-5558e7a1a527
md"""
### 向量的提取
从向量中提取元素是非常简单的， 只要通过中扩号给定下标或一个下标的范围即可。在表示范围时， begin， end两个关键字分别表示第一和最后一个元素的位置。
"""

# ╔═╡ 7fa1ca91-8c28-4a02-8d91-79e23decf30c
xv = collect(1:10)

# ╔═╡ bab0698a-7ec1-4e37-a9b1-c66746062e3e
xv[end]

# ╔═╡ a855e0ec-cb0f-49c8-a9de-fa0e72b1f8ea
xv[1:5]

# ╔═╡ 58a47ef9-3f48-46a3-a0c2-e2030e9d6cbe
xv[5]

# ╔═╡ b3afedf1-ec7b-4c7f-a9fd-d110e319cd91
xv[xv .> 5 ]

# ╔═╡ 1ae9fe95-4028-4ad9-8bea-9e70038d97aa
xv .> 5

# ╔═╡ 83cdb063-631d-4665-99f7-160485675b15
xv[(begin+1):(end-1)]

# ╔═╡ d2bc4dba-f8af-49ed-bede-a4b5a4b0d63c
md"""
### 向量的修改
当向量的提取操作放在赋值号的左边时， 可以实现对向量相应元素的修改。
"""

# ╔═╡ 3f8f066b-8d6c-4503-9223-66a03f3c92cc
xv[3] = 4

# ╔═╡ bdff1fdf-1fb9-4efe-95a8-cfe84b4d1b5c
xv[9:10] = [28, 30]

# ╔═╡ 308270ba-883a-42a6-98ef-84ace09f581f
xv

# ╔═╡ 0243070a-ee48-4909-b14e-dfcd770490f2
md"""
push!函数可以在向量后面增加一个元素， 而pop!函数弹出向量的最后一个元素， 注意， 这两个函数名后面有惊叹号， 表明这种函数会修改参数值。 在这里其实是会修改，输入的数组xv。
"""

# ╔═╡ 80208609-848e-4126-9728-3a4e96073209
push!(xv, 100)

# ╔═╡ d168ee9a-d869-446b-9de7-cd8c5feaf52c
pop!(xv)

# ╔═╡ aeb2f9dc-9337-4417-b6fe-56b89b4e3553
xv

# ╔═╡ 0e8b63aa-60aa-4624-99fc-3201e9ccd0be
md"""
### 向量的统计
求向量的元素个数（length）， 所有元素的和（sum）， 累积和（cumsum）, 相邻元素的差（diff）,最大值（maximum）， 最小值（minimum）, 最大值所在位置argmax, 最小值所在位置argmin
"""

# ╔═╡ 19cb9bbc-0d03-4aab-9817-8c44c1467f1c
vs = rand(1:10, 10)

# ╔═╡ 2fb307cf-3c4c-4496-9d28-6d00045f9a0e
length(vs)

# ╔═╡ ee209254-aaaa-47bc-8742-66b41f5cc1cb
sum(vs)

# ╔═╡ cc1de85e-004f-4dfa-a470-3cb4fc44ccb9
cumsum(vs)

# ╔═╡ f8789abc-2109-4933-b601-a364d4632abb
diff(vs)

# ╔═╡ f17023ef-d835-445d-ba18-bfd5872f0764
maximum(vs),minimum(vs)

# ╔═╡ 3c64486c-4aab-40f4-8fd5-2cfbb74cf856
argmax(vs)

# ╔═╡ ee70a87a-4a0f-49b6-83f9-eaa421300682
argmin(vs)

# ╔═╡ 753dd774-bc71-40a6-866e-99167ec5a635
md"""
## 2.9 矩阵
矩阵也是一种常见的数据类型。 与向量相比， 矩阵是二维的， 即有行、列两个维度。还是可以使用中括号构造矩阵。 这时候， 空格分隔的元素会按行排列。
"""

# ╔═╡ b4f5295a-71a1-45a1-b840-465b97dfa35f
# 空格分隔的元素被排成了一行， 请注意返回结果是一个一行的矩阵， Julia中没有行向量。
[1 2 3]

# ╔═╡ bde035e5-8e89-4f57-82d3-cf4a3538cb62
[1 2 3; 4 5 6]

# ╔═╡ f5910485-4831-4fec-b7c6-dde8da9ea4c4
md"""
矩阵的数据类型是： Matrix{T}，其中T表示元素的类型。例如， 由Int32构成的矩阵是Matrix{Int32}。
"""

# ╔═╡ f434ec9b-f21f-4b13-a2b3-0d1fb3249e1c
md"""
### 简单构造方法
- 特殊数组的构造。 比如全是1或0的数组， ones(m, n)(构造m``\times``n的全1矩阵)， zeros(m, n, k)构造全是0的三维数组。
- 根据已有的数据去构造。 已有一个数组A， 要构造一个跟A的结构一样的（维度，长度都一样）数组， 可用similar函数。 如similar（A）构造一个数据类型和维度跟A完全相同的未初始化数组。
- rand: 可以通过给定维度长度构造（0,1）间的随机数数组， 例如：rand(m, n)构造m*n的随机矩阵。-
- randn: 可以通过给定维度长度构造符合正态分布的随机数数组
"""

# ╔═╡ 465a6a3d-51fa-438d-99cd-d4225e69f891
ones(3,4)

# ╔═╡ da814e35-d7bb-4bb7-880a-1200de12680a
rand(3,4,5)

# ╔═╡ 45a9bbc8-fd43-46c9-b4bb-f0ce8a0cf7cd
md"""
### 矩阵的提取与修改
矩阵元素的提取和修改跟向量是类似的， 只是，矩阵指定元素时， 需要同时给定行，列下标。 单个冒号表示所有元素。
"""

# ╔═╡ 9f143610-c2ac-419a-94c5-aeb832eab25a
m1 = rand(3,4)

# ╔═╡ b8481b81-e60a-460a-bdd2-ad843825c974
m1[3,4]

# ╔═╡ bff39067-4254-4759-ba96-c39fdb21dbc7
m1[:, 1]

# ╔═╡ ab60a221-31ac-4f22-9949-ffcef1bf33bc
m1[1:2, :]

# ╔═╡ c5b7f19b-1d06-4c30-b9d6-700e6d8cb95b
md"""
## 2.10 数组
上面介绍的向量和矩阵是数组的一种特殊情况（1维数组和2维数组）。Julia语言本身对数组提供了非常多的支持。不像Python， 需要使用Numpy包才能处理数据 。 数据具有如下特点 ：1）元素是可变的； 2）数组中所有元素都具有相同类型； 3）数组具有维度；

数组的类型是Array{T,N}， 其中T表示数组元素的类型， N表示数组的维度。 一维数组（向量）也可以表示为Vector{T}, 二维数据可表示为： Matrix{T}
"""

# ╔═╡ f7f76395-39d5-49d7-a9b9-f10d232f46bf
md"""
### 数组的维度
维度是数组特有的一个性质。 在Julia中， 天然的支持多维度的数组。那么，怎么理解维度呢？ 尤其是怎么理解一个多维数组呢？以下，提供一个直观的关于维度的理解--奇怪的图书馆。

想象一个奇怪的图书馆， 其中的书中的文字是按列先从上之下， 再从左至右排列的（这就是奇怪之处）。每一本书就是一个三维数组（对于书来说， 数组中的元素是文字，不是数字）。其中的每一页是一个矩阵。

于是， 第一个维度代表列方向（向下）， 第二个维度代表行方向， 第三个维度是厚度的方向（页数增加的方向）。第四个维度是书架上的最底层，从左到右的方向。第五个维度是书架从低到高增加的方向。 当然还可以继续增加维度， 但实际中用到第五个维度已经很难想象了。

许多数组操作函数都包含一个维度dim参数， 需要结合具体场景理解。
"""

# ╔═╡ 05b2f5c1-cecc-4815-ad4c-87bce0b103ca
md"""
### 数组操作的基本函数
由于Julia是为科学计算设计的， 其包含了非常丰富的数据操作函数， 具体可以参考[**数组文档**](https://docs.julialang.org/en/v1/base/arrays/)， 下面是一些常见的函数。
- eltype： 获取数组的元素类型。
- length： 获取数组的元素个数。
- size： 获取数组各个维度上的长度， 还可以指定维度dim，获取指定维度的长度。 
- reshape: 改变数组的维度
- [i,j,k]: 典型索引操作， 获取（假定是3维数组）第i,j,k号元素(这是笛卡尔坐标表示)。 也可以使用：连续选取， 或者仅用：表示选取所在维度的所有元素。


- **搜索**
|函数名|	搜索的起始点|	搜索方向	|结果值|
|---|---|---|---|
|findfirst|	第一个元素位置|	线性索引顺序|	首个满足条件的元素值的索引号或nothing|
|findlast|	最后一个元素位置|	线性索引逆序|	首个满足条件的元素值的索引号或nothing|
|findnext|	与指定索引号对应的元素位置|	线性索引顺序|	首个满足条件的元素值的索引号或nothing|
|findprev|	与指定索引号对应的元素位置|	线性索引逆序|	首个满足条件的元素值的索引号或nothing|
|findall|	第一个元素位置|	线性索引顺序|	包含了所有满足条件元素值的索引号的向量|
|findmax|	第一个元素位置|	线性索引顺序|	最大的元素值及其索引号组成的元组或NaN|
|findmin|	第一个元素位置|	线性索引顺序|	最小的元素值及其索引号组成的元组或NaN|
"""

# ╔═╡ 8b049907-5266-4066-84db-271b747996d7
tmp = rand(3,4,5)

# ╔═╡ 867b78a8-1183-41b3-ad1c-a0d6db7dc075
size(tmp)

# ╔═╡ 0edff351-2fc8-4759-b2ad-fb5c447119d2
eltype(tmp),length(tmp), size(tmp), size(tmp, 1)

# ╔═╡ f5a96665-ee82-4aec-8db8-59ec603276be
mx = reshape(1:24, 2,3,4)

# ╔═╡ ba31c664-e23f-487d-826f-e259a2b2ccbd
md"""
### 向量堆叠stack
矩阵是由列向量按行排列而成的。因此， 如果我们有一系列等长的向量， 可以将其简单拼接起来就好。
"""

# ╔═╡ c3887ca1-3727-4121-a93d-4fea9fa55e9d
vecs = (1:2, [30, 40], Float32[500, 600]);

# ╔═╡ 6a25736a-190e-4f7a-8625-b4bd10e9c463
stack(vecs)

# ╔═╡ d31c6d68-7929-4420-a3fb-1b4e9f6d2fc4
md"""
### 向量的拼接cat
如果有多个向量需要拼接为一个向量， 可以使用cat函数。
```julia
cat(A...; dims)
```
该函数有一个关键字参数， dims， 用于给定拼接的维度。 也就是把数据放在哪个维度上（单个维度）。 注意， 这里的参数名是复数， 意味着可以同时给多个维度， 这时候拼接的结果是多个维度同时增加。比如， 构造分块矩阵。

在第一个维度拼接也可以用vcat， 在第二个维度拼接可以用hcat。看[**这里**](https://docs.julialang.org/en/v1/base/arrays/#Base.cat)了解更多。
"""

# ╔═╡ 794b30c9-c990-41f6-81e3-9bdae57bffcc
cat([1,2],[3,4], dims=1)# 按第一个维度（行）方向拼接

# ╔═╡ 58eb6102-a11e-419b-a6a2-ce1d38621203
cat([1,2],[3,4], dims=2)# 按第二个维度（列）方向拼接

# ╔═╡ cbd27fc4-ba4e-43b3-8783-6d1bade31447
md"""
下面是按第三个维度（厚度）方向拼接的结果。 这本书有两页， 每一页上只有一列。
"""

# ╔═╡ 281165a4-036e-42c7-bf85-2beab7626fbc
cat([1,2],[3,4], dims=3)

# ╔═╡ bbb0e8bf-ea62-4620-837f-74e9b84b2529
cat([1,2],[3,4], dims=(1,2))

# ╔═╡ a5009256-8294-4596-b5d0-b6ada1d32c9e
vcat([1,2],[3,4])

# ╔═╡ 5ef3aa75-2411-420f-b27a-ee8d792c2455


# ╔═╡ 74cf7b29-05e1-4469-9d64-cadcccdf5cf6
sin(1)

# ╔═╡ 94a3cd24-9221-4f12-9112-ef2117edd009
sin.(1:10)

# ╔═╡ 5ca71a2a-b7c5-494a-b7e4-25dc4b0a11fa
md"""
###  数组推导
数组推导是构建数组的一个常见形式。与python类似，Julia也提供了数组推导式, 通用的格式如下：
- [f(e) for e in colletion if condition]。 这是遍历collection里面的元素， 当满足条件condition时就进行某种操作f， 最后形成一个数组。 e in colletion 也可以写成 e = colletion， if condition可以省略, 下同。
- [f(x,y) for x in c1, y in c2 if condition]。 这种情况下， x,y分别从两个集合c1,c2取值，如果没有if条件，结果是一个矩阵， 矩阵第i,j位置上的元素是f(x[i],y[j])， 由于Julia中矩阵按列存储， 所以会先计算出第1列，再第二列，依次类推； 如果有if条件， 结果是向量， 相当于先计算一个矩阵，再过滤掉不满足条件的元素。  
**注意：**如果外侧不是用[ ]包裹， 那就不是数组推导。 比如， 用（）包裹得到的可不是python里面的元组， 而是生成器了。
"""

# ╔═╡ b5c18a8d-e20c-4a8f-983d-746a20ee41d4
[(x,y) for x in 1:3,  y in 1:4]

# ╔═╡ 21c58017-2d2c-4abd-b7f4-e05fcbd0a936
[sin(x) for x in 1:100 if isodd(x)]

# ╔═╡ 49ec27d1-72ec-4e50-b38e-bef8941e5522
[x + y + z for x in 1:2, y in 3:5, z in 6:9]

# ╔═╡ 92977747-cbc3-41e5-ba86-a8f1bb547a4c
[x + y for x in [1,2,3] , y in [4,5,6,7] if isodd(x)]

# ╔═╡ 8b9e2b3b-4654-40bd-9304-2ac8f520a2b7
[x + y for x in [1,2,3] , y in [4,5,6,7] ]

# ╔═╡ 46662d36-c690-4bb4-998a-6d6ac9b33a51
[e^2 for e in 1:10], [e^2 for e in 1:10 if iseven(e)]

# ╔═╡ 8ca24420-966f-45a5-86f6-ac21b999006e
md"""
## 2.11 范围类型range
范围类型通常用于表示一定范围内具有某种性质的数据构成的集合。最常见的是等差数列, 可以使用冒号运算， 或者range函数构造。
```julia
start:step:stop#step省略的话就是1
range(start, stop, length)
range(start, stop; length, step)
range(start; length, stop, step)
range(;start, length, stop, step)
```
"""

# ╔═╡ 53238993-9668-4412-8d6e-c24bcc3518f3
1:2:10

# ╔═╡ c4d18d69-a8a1-4dd5-862a-4dc4d9a5db44
range(1,10,3)

# ╔═╡ ffc4b3ae-f6d3-4b66-a323-61e256fac24f
range(1,10, length=2 )

# ╔═╡ cef4db28-eea2-4c3f-8a35-71a01f4a3297
3 in 1:2:10

# ╔═╡ 5560ec19-78a4-4c1d-accd-9c07c29c0e18
md"""
可以通过`methods`函数查看一个函数有多少个方法， 下面的结果表明range函数有6个方法。
"""

# ╔═╡ 1c7fbed3-6035-48b9-94ac-2b50086a6a12
methods(range)

# ╔═╡ c18f82cb-f7b3-4f03-b387-b17745e11597
md"""
**函数调用：**上面给出的range函数有四种调用方式，我们应该怎么去调用呢？或者Julia是怎么实现一个名字（range）可以实现多种不同功能的呢？

在编程语言中， 一个名字（函数）在不同语境中可以表示不同含义（不同的调用方式，实现不同的功能），被称为多态。在C++、Python等语言中， 是通过对象实现多态的，即不同的对象调用相同的函数可能得到不同的结果。

在Julia中， 通过**多重分派**实现多态。一个函数名只是给出了一个通用的功能(generic function)。然后对这个功能的不同实现表示该函数的方法（method）。上面就给出的range函数的四个方法。

Julia是怎么根据用户输入的参数去判断要调用哪个方法的呢？答案隐藏在Julia的多重分派（multiple dispatch）里。简单来说， 多重分派的意思是：一个函数在寻找匹配的方法时， 根据其多个参数的类型去确定要调用的方法。当然， 并非所有的参数都会用于多重分派。只有参数列表里，分号；前面的参数（称为**位置参数**）会起作用（也就是给出的位置参数类型及顺序不同， 调用的方法就不同）。这些参数在调用的时候， 不需要给出参数名， 直接按顺序给出参数值即可。分号后的参数通常被称为**关键字参数**， 关键字参数在赋值时， 需要给出关键字的名字。在函数调用时， 位置参数和关键字参数不需要用分号隔开。 所以， 你知道下面的代码的含义吗？
```julia
range(1,10, 2)
range(1,10, length=2 )
range(1,10, step=2 )
```
""" |> kuoz

# ╔═╡ 2dd38b7f-1310-460e-996d-61f104dbfa7d
md"""
## **其他：**[容器类型Collections](https://docs.julialang.org/en/v1/base/collections/)
容器类 型并非一种特定的数据类型， 而是多种数据类型的一种抽象。 直观上来说， 只要可以用于存储多个数据对象的数据结构，都可以看成是容器类型。 上面说到的所有数据类型， 都可以看成是容器类型（Pair对象除外， Pair对象被视为单一元素）。

为什么要单独提容器类型呢？因为Julia中， 很多的操作对容器类型都是有效的。上面给出的向量的统计里的函数， 很多都对容器适用。 具体可以参考每一个函数的文档。 容器类型定义了多种函数， 具体可以参考其[文档](https://docs.julialang.org/en/v1/base/collections/)

在容器类型中， 使用非常频繁的一种是可迭代容器类型Iteration。顾名思义， 可迭代容器类型是指， 这个容器中的元素可以通过for循环依次去遍历。具体内容在下面流程控制部分解释。

"""

# ╔═╡ f4bde725-a4c4-4822-b4db-cd66a21e9944
md"""
# 3 流程控制
流程控制是实现逻辑的重要一环。程序从结构上可以分为顺序结构、分支结构和循环结构三种。默认情况下，程序会顺序执行， 当需要构造分支和循环时， 需要特殊的关键字。在Julia中，有：
1. begin ... end 构造复合语句（在Pluto中，任何一个cell只能输入一条语句， 如果你要输入多条， 则需要用begin...end构造成复合语句）。
2. if elseif else end. 实现分支语句， 当然也有三元操作符?:。
3. for i in collection ... end。 实现固定范围的for循环。
4. while condition... end。 实现基于条件的while循环。
5. continue, break， 用于跳出、提前结束循环。

注意，Julia中任何一个代码块开始关键字都需要以end结尾
"""

# ╔═╡ 974d0237-4e0d-4abc-a52c-649813b6290e
md"""
## 复合语句
当多个语句要组合为一条语句的时候， 需要用到。 下面是三条语句组成的复合语句。该语句的值为复合语句中最后一条语句的值。
"""

# ╔═╡ fd358455-35a1-42d1-bf67-e6b201ad37f2
z1 = begin
           ac = 1
           bc = 2
           ac + bc
       end

# ╔═╡ 03f1bd8c-5eec-41c4-b0bf-4bdabed6319f
begin
	a1 = 1
	a2=2
end

# ╔═╡ 9f65d099-dda1-4c13-b41d-e1c45cc8410c
md"""
Julia并不要求语句有结束符， 不过， 如果我们想多条语句写到同一行中， 可以用分号；分隔即可。当然， begin...end也可以写到一行。
```julia
begin ad = 1; bd = 2; ad + bd end
```
"""

# ╔═╡ e56fb773-68dd-4b1c-b98a-575aea4d1a83
z2 = (ad = 1; bd = 2; ad + bd)

# ╔═╡ 0edb4a14-21f8-462b-8d42-ce95f45aebc3
md"""
## if-elseif-else-end
if语句用于实现分支结构，其基本的用法如下：
基本的使用方法是：
```julia
#单分支条件语句=====================
if 条件
	满足条件要执行的语句
end
```
```julia
# 两分支语句======================
if 条件
	满足条件要执行的语句
else 
	不满足条件要执行的语句
end
```
```julia
# 多分支语句==================elseif可以有多个
if 条件1
	满足条件1要执行的语句
elseif 条件2
	不满足条件1， 满足条件2要执行的语句
elseif 条件3
	不满足条件1、2， 满足条件3要执行的语句
else
	不满足条件1、2、3要执行的语句
end

```
"""

# ╔═╡ a82faf94-ebc6-4f64-9110-cfae5d478c40
md"""
不像C等语言，在Julia中， 要求条件求值的结果必须是bool值， 即true或者false。如果不是， 则程序会错误。（在C语言中， 不是0都当成是true）
""" |> danger

# ╔═╡ 0233e78f-f8cd-449c-9a07-4a4c2bb22bdc
if 1
	println("你是1")
end

# ╔═╡ ba414c29-470a-49c5-996a-917984bc9f91
md"""
println通常用于在控制台输出信息， 表示打印带换行符的元素。Pluto会自动捕捉控制台的输出，显示到下面。不过，在Pluto中， 我们可以直接看到表达式计算的结果， 这比控制台的输出更好看。
""" |> bj

# ╔═╡ 42a8ee30-8f6a-4805-a196-1f50bd1be76e
md"""
单分支语句有一个常用的替换， 也就是利用逻辑运算（&&和||）的**短路求值**。 由于`a&&b`只有在a和b同时为true时才能为ture， 因此， 当a计算的结果为false时， b不需要计算， 只有当a为true时， 才需要计算b的值。因此，
```julia
if 条件
	表达式 
end 
```
可以写成
```julia
条件 && 	表达式 
```
类似的， `a||b`只有在a计算结果为false时， 才需要计算b的值。因此， 当我们要表达不满足某个条件要执行某条语句时， 可以利用或运算。即：

```julia
if 不满足条件(!条件)
	表达式 
end 
```
可以写成
```julia
条件 || 	表达式 
```
可以写成

"""

# ╔═╡ 60d842e5-42c4-46ab-aa2d-0aff5ad559e9
0 && 2

# ╔═╡ eeb589d3-ef08-45e6-96d0-e8a43990f355
md"""
对于双分支语句， 可以用一个简单的表达式表示：
```julia
a ? b : c
```
在这个简单表达式中， a是条件表达式，如果a的测试结果为真true， 则返回表达式b的值， 否则返回表达式c的值。
"""

# ╔═╡ 44f60c42-a622-46a7-9b13-334bc7f2b1a4
md"""
你可以输入两个不同的值xn= $(@bind xn  NumberField(1:10, default=3)) ， yn= $(@bind yn  NumberField(1:10, default=4))， 然后下面的语句会根据你输入的值的大小比较结果输出不同的值。
"""

# ╔═╡ a36cc9c3-e097-4093-b9dc-29821c60e251
println(xn < yn ? "xn < yn" : "xn >= yn")

# ╔═╡ c4da3c06-2269-4b56-8f0c-c797d4195e5b
md"""
下面的代码根据你选择的不同， 会告诉你选择的对象是什么
"""

# ╔═╡ 5d23e533-861d-4501-ac66-da666f0ef4e3
md"""
你可以选择一个动物，  $(@bind animal Select(["🐂", "🐝", "🐱"]))， 下面的代码块就会告诉你，你选择的是什么动物。
"""

# ╔═╡ 84d5071e-2b91-4341-8839-0352172afb7d
begin
	# 这是一个 if 语句，缩进不是必要的
	if animal == "🐂"
	    println("你选择的是牛.")
	elseif animal == "🐝"    # elseif 是可选的.
	    println("你选择的是蜜蜂.")
	else                    # else 也是可选的.
	    println("你选择的是猫.")
	end
	# => prints "some var is smaller than 10"
end

# ╔═╡ 2e677cda-c26f-445f-8f18-a7b1e55180b8
md"""
## for/while 循环
当我们需要重复的做一件事情时， 可以使用for循环或while循环。

for 循环的典型用法如下：

```julia
for 循环变量 in（或者=） 容器
	# 做点事情， 一般会跟循环变量有关
	...
end
```
在for循环中， 循环变量会依次取容器中的每一个值。 所以， 在每一次循环， 循环变量的值可能都不同。 `循环变量 in（或者=） 容器 ` 表示: `循环变量 in 容器`或者 `循环变量 = 容器`都是合法的语法。 注意， 这时候的等号=不是将容器赋值的意思，而是容器中的元素依次赋值。
```julia
while 条件
    # 条件满足时，要做的事情
	...
end
while循环更简单， 只要条件能够满足， 就会执行while 和 end之间的代码。只是请注意，跟if语句中的条件一样， 这里的条件也必须是逻辑值。 
```

for循环用于遍历一个容器collection。
"""

# ╔═╡ c247f64b-457a-4bb7-88dd-a9d2ecc3ae0e
md"""
比如， 求 ``1+2+\cdots+100`` 的和，用for循环可以非常方便的实现：
```julia
s = 0
for i in 1:100
	s += i
end
```
如果用while循环， 也可以这样：
```julia
s = 0
i = 1
while i<=100
	s += i
	i += 1
end
```
上面两段代码中s最后的值都是索要的结果。
"""

# ╔═╡ e6181b7f-d65a-4ce0-b12a-cb76169cb0f6
begin
s = 0
for i in 1:100
	s += i
end
end

# ╔═╡ 212cf3bc-a0b2-4f8d-bb51-5e6104d17287
md"""
如果要遍历一个字典， 可以简单如下：
```julia
for (k,v) in D
	# 做一些事情
end
```
其中， k存储每一个元素的键key， v用于存储值value。	
"""

# ╔═╡ 602ea0fd-eb5c-4129-9987-02bf23074292
md"""
如果在遍历一个容器的时候， 我们不仅需要值， 还希望知道当前的值是第几个元素。这时候， 可以这么做。
```julia
for (i, x) in enumerate(collection)
 # 做一些事情
end
```
这时候， 变量i保存遍历过程中元素的顺序（从1开始）， 变量x保存相应元素的值（第i个元素的值）。`enumerate(iter)`的作用是生成一个可迭代对象(i,x)。

比如， 我们要找到一个向量中的元素的最大值是哪个元素， 虽然有函数实现， 但可以用如下for循环:
```julia
v = rand(1:10, 10) # 从1:10中随机抽取10个元素构成向量。
ind = 1 # 用于保存最大值所在位置
for (i,x) in enumerate(v)
	if v[i]> v[ind] # 如果发现一个更大值
		ind = i # 更新最大值所在位置
	end
end
```
"""

# ╔═╡ 9ea456f7-0e60-44d5-8e5a-1ad3efe71996
md"""
## 迭代类型（Iteration）
可迭代类型一种可以用for循环遍历的数据容器。
```julia
for i in iter   # or  "for i = iter"
    # body
end
```
说迭代类型是容器其实不太确切。 因为可迭代类型并没有将数据存起来， 数据是在迭代的过程中不断计算出来的。 因此， 可迭代类型的数据可能是一个无穷集合。想象一下， 我们肯定没办法构建一个包含无穷多个元素的向量（因为内存限制）。


一个可迭代类型， 只是在该类型上，定义了一个iterate函数：

`iterate(iter [, state]) -> Union{Nothing, Tuple{Any, Any}}`

该函数实现在迭代对象上（iter）， 根据当前的状态（state）， 获取容器中的下一个值和下一个状态。 一般， 值和状态构成一个元组。 如果容器中的元素全部取出， 那么再次迭代获取的值将是nothing。 

有了这样的特征设定， 上面的for循环其实被转换为下面的while循环：

```julia

next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end
```

一个迭代类型可能还实现了IteratorSize和IteratorEltype等特性， 可以用于求迭代器中的元素数量和元素类型。 当然， 只要定义了上面的iterator函数， 一个迭代器类型就自动实现了很多操作。

上面介绍的所有数据结构都是可迭代类型。因此， 任何适用于可迭代类型的函数， 将适用于上面介绍的所有数据类型。
"""

# ╔═╡ 40d31e37-ad99-44c3-98e6-494b07d42d66
md"""
# 4 函数
在数学上， 一个函数是一个映射``f:x\rightarrow y``, 它将自变量变为因变量。 在变成语言中， 函数的内涵更丰富。 简单来说， 一个函数就是一个功能function， 这个功能可以将一定的**输入**（可以没有），转化为**某种输出**。 

输入也称为**参数列表**， 一般用括号形成的元组表示。 函数的输出是函数的返回值（return），默认情况下是函数的最后一条语句的计算结果。 


函数编写是一门语言非常重要的内容， 有了上述流程控制的内容， 编写函数就容易多了。 在Julia中， 有多种定义函数的方法。

## 4.1 经典定义
定义函数很简单， 用关键词 function， 给出函数名， 参数列表， 和函数体（函数的计算过程）即可。例如：
```julia
function f(x,y)
	x^2 + y^2
end
```
上面的函数定义中， `function ... end`之间的部分就是函数的部分。其中， `f`是函数名， `(x,y)`是参数列表， 其下一行`x^2 + y^2`是函数体。 这个函数很简单， 只是返回这两个参数的平方和。
"""

# ╔═╡ 5bc53b65-b68d-4d55-b74e-874b27c332dc
f(x) = 3*x^2+4

# ╔═╡ 1493f40e-1b5c-4cb3-a606-393beee8c0b5
f(3)

# ╔═╡ 11a3dd19-92ce-48c1-ae23-4b36a3a5e333
md"""
## 4.2 一句话函数
有时候， 我们的函数可能很简单（只有一句话）， 那么像上面那样去定义会显得啰嗦。这时候可以使用赋值直接定义。

```julia
f(par1, par2, ...) = 表达式
```
这种写法类似于数学函数的写法， 比如二次函数$f(x) = 3x^2 + 2x + 1$， 写成一个Julia函数，几乎是一样的。注意在下面，数字和字母x之间可以没有乘号*， Julia自己能判断这种情况是省略乘号的乘法（是不是很数学？）， 因为变量不能以数字开头去命名。
```julia
f(x) = 3x^2 + 2x + 1
```
当然， 这里的“一句话”可以是复合语句， 比如：`begin ... end`包裹的多句话， 或者元组形式的多句话 `(语句1；语句2；语句3)`。
"""

# ╔═╡ a13a3943-3189-4ec5-be1e-1eabf1462118
md"""
## 4.3 匿名函数
有时候， 我们只是临时需要一个功能， 不想给它命名， 这时候可以用匿名函数的形式， 这是最想映射的定义方式：
```julia
(parlist) -> 表达式
```
匿名函数没有名字， 所以我们没法直接调用它。 一般匿名函数都是作为参数输入一个函数。 比如，在Julia中，有一个函数map， 其签名为
```julia 
map(f, c...) -> collection
``` 
该函数可以将一个函数`f`映射到一个容器中


一般出现在一个函数的参数需要一个函数时。 通常这种函数会比较简单。 当匿名函数可能很复杂时， 可以使用do形式。 下面的do end之间的部分是一个匿名函数， 函数的参数是x。 这个函数将作为map的第一个参数。这种写法也被称为do代码块。

```julia
map(1:10) do x
    2x
end
"""

# ╔═╡ f54e0a94-b6f2-4fe4-8c59-d4fbbb27c727
map(x -> x^2, 1:5)

# ╔═╡ a3e15840-ec8d-4d13-802f-018d665086f2
sin.(1:5)

# ╔═╡ 2102c883-4c2f-461b-bfea-5421c9bfcae8
md"""

## 4.4 函数参数
函数参数有两种类型： 位置参数和关键字参数， 每一种又分可选和必选， 位置参数和关键字参数在定义时用分号(；)分隔。 其中位置参数是通过位置来确定参数的赋值， 因此， 调用函数时， 提供的参数的顺序必须要跟对应的位置参数完全匹配。 关键字参数具有一个参数关键字， 调用的时候需要带着关键字去调用， 这时自然也不需要关注顺序的问题。 下面定义的函数`f`的参数中， `a,b...`是必选位置参数， `m,n,...`是可选位置参数（必选位置参数必须在可选位置参数之前）， 可选的意思是，如果没有给定也没关系（因为有默认值）。 分号之后的`key1, key2, ...`等是关键字参数， 关键字参数也可以提供默认值, 成为可选的关键字参数（否则就是必选的关键字参数， 没有必选要在可选之前的规定）。 注意， 位置参数调用时不能指定参数名， 指定参数名， 必然意味着这个参数是关键字参数。 Julia中函数会根据位置参数及其类型实现多重分派(同一函数名， 根据不同的输入参数实现不同的功能)， 细节请参考相关文档。
```julia
function f(a,b,..., m=x1, n=x2, ...; key1, key2 = xk, ...)
#
end

```
"""

# ╔═╡ 14498fbd-eb00-4291-990a-4583bd008587
plantuml"""
@startmindmap
*: f(**a,b,** 
   ""m=x1, n=x2 **;**"" 
   **key1, key2,**
   ""key3 = xk ""
);
**:位置参数
分号之前;
***: **必选参数**
1. 参数按顺序赋值
2. 赋值的时候不要写参数名
3. 比如a,b,...，都是必选参数
4. f(1,2,3)调用时会将1,2,3依次赋值给a,b,m。
;
***: **可选参数**
1. 如果一个参数提供了默认值，该参数就变为可选参数
2. 可选参数在调用时如果没有赋值， 就使用默认值。
    如果有赋值， 采用给出的值。
;
**:关键字参数
 分号之后;
***: 必选参数（必须要
按顺序赋值）;
***: 可选参数（已
经有默认值）;



@endmindmap
"""

# ╔═╡ ebd59160-9185-4837-bec6-cdd4c4a9acc3
function f1(a,b, m=1, n=2; key1 = 4, key2=10)
#
	a + b + m + n + key1 + key2
end

# ╔═╡ 847d06b7-826c-4aea-9074-69182ec78871
f1(1,2,3,4,key1 = 5, key2 = 6)

# ╔═╡ 032ecfce-4068-423e-ad16-dc007881af26
function ftest(x,y=10;a=1,b)
x + y + a + b
end

# ╔═╡ f013daac-f334-400e-b6f2-d7ebc95d02b4
ftest(1,b=9)

# ╔═╡ e8c1a367-e3f3-4b0d-a0f9-2aa6a80b1123
md"""
## 4.5 ...操作符
"""

# ╔═╡ fa8f6be1-2429-499c-ac43-022a341bb71f
md"""
这个三点操作符是Julia中一个特殊的操作符， 在Julia中有两种作用，可以参考[`...文档`](https://docs.julialang.org/en/v1/manual/faq/#What-does-the-...-operator-do?)了解更多。

在函数定义的场景中， 可以表示“卷入”操作：把多个参数卷到一个参数上。比如在下面的函数定义， 只有一个参数，args，但args后面有三个点，他表示不管你输入多少个参数， 都将被卷入args这个变量里。当然这个变量会是一个团组，包含你给的所有参数。
```julia

function printargs(args...)
        println(typeof(args))
        for (i, arg) in enumerate(args)
            println("Arg #$i = $arg")
        end
end
```
"""

# ╔═╡ 4cf0696e-e821-471e-96df-1f6237008e9d
function printargs(args...)
        println(typeof(args))
        for (i, arg) in enumerate(args)
            println("Arg #$i = $arg")
        end
end

# ╔═╡ be9a3bb9-7ae6-465c-ac37-5f239d7aa49e
printargs(1, 2, 3,4)

# ╔═╡ dacd9f4a-924d-4cd3-a2d4-5a5753d2335e
md"""
三点操作符的另一个用法是展开， 通常，它可以将其前面的对象展开成一个一个元素组成的元组。这个用法经常出现在函数调用的场景， 我们给函数的参数，看上去可能只有一个， 但我们可以将这个参数展开， 得到多个值，分配给多个参数。
"""

# ╔═╡ 1aef68dd-ed5a-4c0c-aa02-d1fc956f7f24
tx = [1,2,3]

# ╔═╡ 7926b299-ba82-4ce1-ae1b-077e4150f71c
(tx...,)

# ╔═╡ 31c0e9d3-e4a3-4f9d-80f2-22e4cbd70ca8
printargs(tx...)

# ╔═╡ ce26d829-a7de-4194-96ef-9a81732db012
md"""
在Julia中， 有一个关于函数的习惯，**如果一个函数会修改其输入参数，该函数名要以！结尾**。 反过来， 如果发现一个带惊叹号的函数， 那么要知道这个函数会修改输入参数。
""" |> kuoz

# ╔═╡ 9603700b-cd87-4873-b452-0fd0a9395c76
md"""
## 函数编写练习
"""

# ╔═╡ 1a1ec8e6-87f4-4ecd-82c9-141949b5c061
md"""
### Ex1. 编写一个函数，用于返回一个向量的2范数。
""" |> lianx

# ╔═╡ 86d11ad1-4842-4bdf-9e46-92ef48c3d9ef
norm(v) = sqrt(sum(v.^2))

# ╔═╡ 5a15f415-2959-4b80-ba2d-bf3edaf1f193
norm(v1, v2) = norm(v1 .- v2)

# ╔═╡ 6f386ffe-d3ec-40a9-80e7-30c8e4625fb5
norm(ones(10), 2*ones(10))

# ╔═╡ aa9f08f4-c5bc-4312-aa2d-545069969c38


# ╔═╡ ab0b7723-6c28-4616-af5f-1e67b62fb03a
md"""
### Ex2. 编写一个函数， 用于实现对向量的最小-最大规范化。
在数据分析中， 因为不同的变量可能存在不同的量纲， 导致数据的大小分布情况是不一致的。 为了减少量纲的影响， 通常我们需要将数据转换到相同的尺度， 这称为数据的规范化。  最小-最大规范化是利用向量的最小-最大值将数据转换到给定的区间， 通常为[0,1]。 即
$$z = \frac{x - min_x}{max_x - min_x}$$
""" |> lianx

# ╔═╡ 6276c42a-af0e-4277-8dc3-746f7466c010
function zminmax(v)
	dn = minimum(v)
	up = maximum(v)

	(v .- dn) ./ (up - dn)
end

# ╔═╡ b7433a36-3b91-4dcc-9cc8-bd2ea996f0b5
zminmax([4,5,6,7,10])

# ╔═╡ d851527a-d303-4870-b4a4-b393b138d2c2
md"""
### Ex3. 编写一个函数， 输入参数是一个表示年龄的整数， 输出结果是年龄代表的类别：老中青三种之一。判断条件是：年龄>60岁为老， [40, 60]为中， <40为青。
""" |> lianx

# ╔═╡ bd574d52-e848-4a5a-a3b2-6b5e2264ceb5
function getclass(age)
	if age > 60
		return "老"
	elseif age >= 40
		return "中"
	else
		return "青"
	end
end

# ╔═╡ 9813645e-5070-4be6-afe3-66ced0456c22
getclass(100)

# ╔═╡ 9db85a08-3b02-4e12-ac20-d5e6e10addcb
md"""
# 5 自定义类型（高级）
在Python中， 我们可以编写类（Class）。一个类， 有自己的数据和相应的方法。 在Julia中， 我们仍然可以编写自己的数据类型， 但方法已经不再是跟数据绑定在一起了。 编写自定义的数据类型（复合类型）很简单， 只需要用struct关键字：
```
[mutable] struct Typename
field1
field2
...
end
```
默认的复合内容是不可修改的， 为了让结构中各个域可修改， 可在定义之前加关键字mutable。 此外， struct的各个域也可以通过`::Type`指定相应的类型。 

通常情况下， 数据类型会有自动生成构造函数。 默认的构造函数， 函数名就是类型名， 参数会依次赋值给每一个域。如果数据类型不同， 会尝试用convert转换后去赋值， 如果转换不了， 则会构造失败。 下面的代码可以定义平面上的一个点（x, y）。 然后用`Point2D(3, 4)`则可以生成一个具体的点。
```
struct Point2D
	x::Float32
	y::Float32
end
```

在一些高级语言中， 我们可以定义类(class)， 类中同时具有数据和可以绑定方法。 Julia的自定义类型不能在类型定义时定义方法。 但我们可以基于类型定义相应的函数（这种函数， 有时候称为函子）。 比如， 下面的代码我们希望定义一个多项式， 用coeffs来存储多项式的系数：
```
struct Polynomial
	coeffs
end
```
定义了这个多项式的表示类型之后， 我们可以定义该类型绑定的函数如下， 这个函数没有函数名， 函数名对应的是一个类型名， 前面的p在具体调用的时候会指向类型的对象。
```
function (p::Polynomial)(x)
	v = p.coeffs[end]
for i = (length(p.coeffs)-1):-1:1 
	v = v*x + p.coeffs[i]
end
	return v
end
```

此后， 在我们构造了类型的对象之后， 我们就可以用对象去调用这个函数了。 
```
t = Polynomial([1,10,100])
t(5)
```

这种通过给类型加方法使得类型的对象变得可被调用的机制(有点类似于Python中通过class定义数据和方法的过程)， 在一些高级的编程场合使用非常广泛， 比如， 在神经网络中， 就可以通过这种方式定义一种特殊的数据类型， 代表特殊的网络层， 然后定义相应的类型方法， 在初始化之后， 就可以通过对象去计算结果了。 可以把这种机制看成是面向对象编程的一种模拟。
"""

# ╔═╡ 355c0db5-ddfc-4af2-8902-1bcf0cacfb97
struct Point2D
x::Float32
y::Float32
end

# ╔═╡ aa9b6d9c-2999-4a48-8fd5-b3d94d1b3a68
md"""
## 复合类型Composite Type
在面向对象的编程语言中， 比如Python， 我们可以定义自己的类（class）。一个类可以包含一些字段（数据）， 同时也会有这个类的对象可以调用的相关函数（方法）。 一般， 类实例化之后被称为对象（object）。要调用相关函数， 我们需要使用`对象.方法`这样的语法形式， 这表明， 方法是由对象的类决定的。 在Julia中， 数据和方法是分开的。决定调用何种方法是由函数的位置参数共同决定的（多重分派），而不仅仅是函数的第一个参数。这种将数据跟方法解耦的方式具有非常多的优势。

因此， 在Julia中，我们不能定义类， 但可以定义包含一些字段的数据类型--复合类型。简单来说， 复合类型就是一个把多个名字绑定为一个整体的数据类型。 类似在C语言中， Julia使用struct关键字定义复合类型。
```julia
struct Point
	x
	y
end
```
上面定义了一个名为Point的复合类型。在该类型中， 有两个名字(字段field)。 这个定义很简单， 你可以给两个字段赋予任何的值。因为，我们没有对字段的数据类型做任何的限制， 这种情况下是默认类型Any。当然， 对于特定的应用来说， 我们限制字段的类型是有好处的（可以获得更快的代码）。如果我们要对类型做出限制， 可以使用类型断言符--两个冒号`::` 

```julia
struct Point
	x::Float32
	y::Float32
end
```
在这个定义里， 我们限制了字段的类型的字段只能是32位的浮点数。 
"""

# ╔═╡ e4505a13-2039-47e1-aa88-9eaa230013de
md"""
在Julia中， 如果我们定义类型的话， 习惯上， 使用大写字母开头的名字，涉及多个单词时， 每个单词首字母大写
""" |> kuoz

# ╔═╡ 3cb96773-fac7-493a-b374-ecca5eb2c3a8
struct Point
	x::Float32
	y::Float32
end

# ╔═╡ 15ddb8f6-a00a-45ec-a8cb-fa7add86f2f1
fieldnames(Point)

# ╔═╡ ec5c39ef-2641-4029-9abf-98eee3fe767e
p = Point(2,3)

# ╔═╡ 0842a2f8-a087-447b-929d-e59c60d9d8d0
p.x, p.y

# ╔═╡ 66d2514c-7deb-4f93-bc19-318812a9da2d
md"""
用struct直接定义的类型默认是不可修改的。比如，下面试图修改p的坐标的操作会失败。
"""

# ╔═╡ b1c32cd1-da0b-45fb-ad89-681b76d9df43
p.x = 4

# ╔═╡ 46c158c3-ab1b-43aa-9eb0-dd2a47b8406a
md"""
如果要定义可以修改的类型， 需要在struct的前面加mutable关键词。即如下定义：
```julia
[mutable] struct Typename
field1
field2
...
end
```
"""

# ╔═╡ 5030ce0e-9d61-455c-8203-c6bfa4731a95
md"""
## 构造函数
定义了复合类型之后， 如何构造复合类型的对象呢？ 简单来说, 把复合类型像函数一样调用就可以得到一个该类型的对象。 比如，上面定义的Point， 那么我们可以通过`Point（2,3）`构造一个点（2,3）。 我们可以通过 `对象.字段名` 的方式获取对象的特定字段的值。 你可以通过`fieldnames(类型名)`函数获取一个类型的所有的字段名。
"""

# ╔═╡ 0042e8a0-61be-4768-ae31-0445d531e5ff
md"""
我们把一个复合类型当成函数调用， 实际上是调用了类的默认构造函数`constructor`。 一般一个复合类型在定义之后， Julia会自动为其提供两个默认构造函数：一个接受任意类型参数的构造函数和一个接受精确类型参数的构造函数。 接受任意类型参数的构造函数会自动调用convert函数将参数转化为类型指定的类型。 比如， 上面构造的点p， 我们输入的数据是整数2,3， 但仍然能正确构造出对象，是因为整数可以转化为浮点数。
"""

# ╔═╡ 3e5074ba-9b55-417f-99b8-b1ff3796c969
p.x, p.y

# ╔═╡ 6900f9dc-1655-458a-8592-cb25c4319b92
md"""
### Ex4. 用结构体重写Ex2.
在建模过程中， 我们对原始数据施加了某个变换， 当新的样本来临时， 我们仍需要进行同样的变换才能用于模型的预测。 这时候， 我们需要将变换保存起来， 在后续碰到新的数据时， 再使用它去做变换。 这意味着， 我们需要存储变换过程中使用到的值。 为了实现这一点， 我们用一个结构体表示一个变换。

下面先定义最小-最大变换结构体。

""" |> lianx

# ╔═╡ 30f934d3-9ece-43df-9f12-bbe2805a4120
mutable struct MinMax
	dn
	up
end

# ╔═╡ 5703fed8-0c25-4a94-a70a-626f90817cd0
md"""
因为我们会在模型训练的时候修改这个结构体中存的值。所以我们需要将模型定义为mutable的。

有了结构体之后， 相当于我们有了一个抽象的变换。 当我们给定一个向量去“训练”后， 我们就可以用这个变换去变换数据了。
"""

# ╔═╡ 0b66c477-02be-44f8-ad85-a44824c3d24f
function fit!(t::MinMax, v)
	t.dn = minimum(v)
	t.up = maximum(v)
end

# ╔═╡ d32932e7-a200-4833-962c-aa1de136598d
T1 = MinMax(0,0)

# ╔═╡ 5f555381-cf5c-4122-957f-f01f5dca8cf1
fit!(T1, [4,5,6,7,10])

# ╔═╡ b9838c1d-9a89-4529-8c91-60a1f03eb503
T1

# ╔═╡ 693010e2-de30-4902-b24e-a5a3fdf15737
function transform(T::MinMax, v)
	(v .- T.dn) ./ (T.up - T.dn)
end

# ╔═╡ 6cb35f5f-20dd-4c44-9843-3687d847882d
transform(T1, [4,5,6,7,10])

# ╔═╡ 76e9e262-0599-4e9f-9a49-1a223602cfec
md"""
当有新的数据需要转换时
"""

# ╔═╡ 99f1f97b-d6cd-4d7b-a41f-73ae9c1786ce
transform(T1, [8,12])

# ╔═╡ 57f0cdb1-b4d0-45c3-97a1-59f42c369df9
md"""
有时候， 可能还需要逆变换， 比如知道变换后的值是 0.7， 变换之前是多少？
"""

# ╔═╡ 14f0ed67-7a2c-4ed1-9630-163d95de5bae
function inverse_transform(t::MinMax, v)
	v .* (t.up - t.dn) + t.dn
end 

# ╔═╡ 818fab0d-f4ae-41cd-a00f-874e3ef8aa54
inverse_transform(T1, 0.166667)

# ╔═╡ 00000000-0000-0000-0000-000000000001
PLUTO_PROJECT_TOML_CONTENTS = """
[deps]
Kroki = "b3565e16-c1f2-4fe9-b4ab-221c88942068"
PlutoUI = "7f904dfe-b85e-4ff6-b463-dae2292396a8"

[compat]
Kroki = "~0.2.0"
PlutoUI = "~0.7.50"
"""

# ╔═╡ 00000000-0000-0000-0000-000000000002
PLUTO_MANIFEST_TOML_CONTENTS = """
# This file is machine-generated - editing it directly is not advised

julia_version = "1.9.3"
manifest_format = "2.0"
project_hash = "c55691993725eb5b2d2c84fed85041b15e0e074c"

[[deps.AbstractPlutoDingetjes]]
deps = ["Pkg"]
git-tree-sha1 = "91bd53c39b9cbfb5ef4b015e8b582d344532bd0a"
uuid = "6e696c72-6542-2067-7265-42206c756150"
version = "1.2.0"

[[deps.ArgTools]]
uuid = "0dad84c5-d112-42e6-8d28-ef12dabb789f"
version = "1.1.1"

[[deps.Artifacts]]
uuid = "56f22d72-fd6d-98f1-02f0-08ddc0907c33"

[[deps.Base64]]
uuid = "2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"

[[deps.BitFlags]]
git-tree-sha1 = "43b1a4a8f797c1cddadf60499a8a077d4af2cd2d"
uuid = "d1d4a3ce-64b1-5f1a-9ba4-7e7e69966f35"
version = "0.1.7"

[[deps.CodecZlib]]
deps = ["TranscodingStreams", "Zlib_jll"]
git-tree-sha1 = "02aa26a4cf76381be7f66e020a3eddeb27b0a092"
uuid = "944b1d66-785c-5afd-91f1-9de20f533193"
version = "0.7.2"

[[deps.ColorTypes]]
deps = ["FixedPointNumbers", "Random"]
git-tree-sha1 = "eb7f0f8307f71fac7c606984ea5fb2817275d6e4"
uuid = "3da002f7-5984-5a60-b8a6-cbb66c0b333f"
version = "0.11.4"

[[deps.CompilerSupportLibraries_jll]]
deps = ["Artifacts", "Libdl"]
uuid = "e66e0078-7015-5450-92f7-15fbd957f2ae"
version = "1.0.5+0"

[[deps.ConcurrentUtilities]]
deps = ["Serialization", "Sockets"]
git-tree-sha1 = "5372dbbf8f0bdb8c700db5367132925c0771ef7e"
uuid = "f0e56b4a-5159-44fe-b623-3e5288b988bb"
version = "2.2.1"

[[deps.Dates]]
deps = ["Printf"]
uuid = "ade2ca70-3891-5945-98fb-dc099432e06a"

[[deps.DocStringExtensions]]
deps = ["LibGit2"]
git-tree-sha1 = "2fb1e02f2b635d0845df5d7c167fec4dd739b00d"
uuid = "ffbed154-4ef7-542d-bbb7-c09d3a79fcae"
version = "0.9.3"

[[deps.Downloads]]
deps = ["ArgTools", "FileWatching", "LibCURL", "NetworkOptions"]
uuid = "f43a241f-c20a-4ad4-852c-f6b1247861c6"
version = "1.6.0"

[[deps.ExceptionUnwrapping]]
deps = ["Test"]
git-tree-sha1 = "e90caa41f5a86296e014e148ee061bd6c3edec96"
uuid = "460bff9d-24e4-43bc-9d9f-a8973cb893f4"
version = "0.1.9"

[[deps.FileWatching]]
uuid = "7b1f6079-737a-58dc-b8bc-7a2ca5c1b5ee"

[[deps.FixedPointNumbers]]
deps = ["Statistics"]
git-tree-sha1 = "335bfdceacc84c5cdf16aadc768aa5ddfc5383cc"
uuid = "53c48c17-4a7d-5ca2-90c5-79b7896eea93"
version = "0.8.4"

[[deps.HTTP]]
deps = ["Base64", "CodecZlib", "ConcurrentUtilities", "Dates", "ExceptionUnwrapping", "Logging", "LoggingExtras", "MbedTLS", "NetworkOptions", "OpenSSL", "Random", "SimpleBufferStream", "Sockets", "URIs", "UUIDs"]
git-tree-sha1 = "19e974eced1768fb46fd6020171f2cec06b1edb5"
uuid = "cd3eb016-35fb-5094-929b-558a96fad6f3"
version = "1.9.15"

[[deps.Hyperscript]]
deps = ["Test"]
git-tree-sha1 = "8d511d5b81240fc8e6802386302675bdf47737b9"
uuid = "47d2ed2b-36de-50cf-bf87-49c2cf4b8b91"
version = "0.0.4"

[[deps.HypertextLiteral]]
deps = ["Tricks"]
git-tree-sha1 = "c47c5fa4c5308f27ccaac35504858d8914e102f9"
uuid = "ac1192a8-f4b3-4bfe-ba22-af5b92cd3ab2"
version = "0.9.4"

[[deps.IOCapture]]
deps = ["Logging", "Random"]
git-tree-sha1 = "d75853a0bdbfb1ac815478bacd89cd27b550ace6"
uuid = "b5f81e59-6552-4d32-b1f0-c071b021bf89"
version = "0.2.3"

[[deps.InteractiveUtils]]
deps = ["Markdown"]
uuid = "b77e0a4c-d291-57a0-90e8-8db25a27a240"

[[deps.JLLWrappers]]
deps = ["Artifacts", "Preferences"]
git-tree-sha1 = "7e5d6779a1e09a36db2a7b6cff50942a0a7d0fca"
uuid = "692b3bcd-3c85-4b1f-b108-f13ce0eb3210"
version = "1.5.0"

[[deps.JSON]]
deps = ["Dates", "Mmap", "Parsers", "Unicode"]
git-tree-sha1 = "31e996f0a15c7b280ba9f76636b3ff9e2ae58c9a"
uuid = "682c06a0-de6a-54ab-a142-c8b1cf79cde6"
version = "0.21.4"

[[deps.Kroki]]
deps = ["Base64", "CodecZlib", "DocStringExtensions", "HTTP", "JSON", "Markdown", "Reexport"]
git-tree-sha1 = "a3235f9ff60923658084df500cdbc0442ced3274"
uuid = "b3565e16-c1f2-4fe9-b4ab-221c88942068"
version = "0.2.0"

[[deps.LibCURL]]
deps = ["LibCURL_jll", "MozillaCACerts_jll"]
uuid = "b27032c2-a3e7-50c8-80cd-2d36dbcbfd21"
version = "0.6.3"

[[deps.LibCURL_jll]]
deps = ["Artifacts", "LibSSH2_jll", "Libdl", "MbedTLS_jll", "Zlib_jll", "nghttp2_jll"]
uuid = "deac9b47-8bc7-5906-a0fe-35ac56dc84c0"
version = "7.84.0+0"

[[deps.LibGit2]]
deps = ["Base64", "NetworkOptions", "Printf", "SHA"]
uuid = "76f85450-5226-5b5a-8eaa-529ad045b433"

[[deps.LibSSH2_jll]]
deps = ["Artifacts", "Libdl", "MbedTLS_jll"]
uuid = "29816b5a-b9ab-546f-933c-edad1886dfa8"
version = "1.10.2+0"

[[deps.Libdl]]
uuid = "8f399da3-3557-5675-b5ff-fb832c97cbdb"

[[deps.LinearAlgebra]]
deps = ["Libdl", "OpenBLAS_jll", "libblastrampoline_jll"]
uuid = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"

[[deps.Logging]]
uuid = "56ddb016-857b-54e1-b83d-db4d58db5568"

[[deps.LoggingExtras]]
deps = ["Dates", "Logging"]
git-tree-sha1 = "0d097476b6c381ab7906460ef1ef1638fbce1d91"
uuid = "e6f89c97-d47a-5376-807f-9c37f3926c36"
version = "1.0.2"

[[deps.MIMEs]]
git-tree-sha1 = "65f28ad4b594aebe22157d6fac869786a255b7eb"
uuid = "6c6e2e6c-3030-632d-7369-2d6c69616d65"
version = "0.1.4"

[[deps.Markdown]]
deps = ["Base64"]
uuid = "d6f4376e-aef5-505a-96c1-9c027394607a"

[[deps.MbedTLS]]
deps = ["Dates", "MbedTLS_jll", "MozillaCACerts_jll", "Random", "Sockets"]
git-tree-sha1 = "03a9b9718f5682ecb107ac9f7308991db4ce395b"
uuid = "739be429-bea8-5141-9913-cc70e7f3736d"
version = "1.1.7"

[[deps.MbedTLS_jll]]
deps = ["Artifacts", "Libdl"]
uuid = "c8ffd9c3-330d-5841-b78e-0817d7145fa1"
version = "2.28.2+0"

[[deps.Mmap]]
uuid = "a63ad114-7e13-5084-954f-fe012c677804"

[[deps.MozillaCACerts_jll]]
uuid = "14a3606d-f60d-562e-9121-12d972cd8159"
version = "2022.10.11"

[[deps.NetworkOptions]]
uuid = "ca575930-c2e3-43a9-ace4-1e988b2c1908"
version = "1.2.0"

[[deps.OpenBLAS_jll]]
deps = ["Artifacts", "CompilerSupportLibraries_jll", "Libdl"]
uuid = "4536629a-c528-5b80-bd46-f80d51c5b363"
version = "0.3.21+4"

[[deps.OpenSSL]]
deps = ["BitFlags", "Dates", "MozillaCACerts_jll", "OpenSSL_jll", "Sockets"]
git-tree-sha1 = "51901a49222b09e3743c65b8847687ae5fc78eb2"
uuid = "4d8831e6-92b7-49fb-bdf8-b643e874388c"
version = "1.4.1"

[[deps.OpenSSL_jll]]
deps = ["Artifacts", "JLLWrappers", "Libdl"]
git-tree-sha1 = "a12e56c72edee3ce6b96667745e6cbbe5498f200"
uuid = "458c3c95-2e84-50aa-8efc-19380b2a3a95"
version = "1.1.23+0"

[[deps.Parsers]]
deps = ["Dates", "PrecompileTools", "UUIDs"]
git-tree-sha1 = "716e24b21538abc91f6205fd1d8363f39b442851"
uuid = "69de0a69-1ddd-5017-9359-2bf0b02dc9f0"
version = "2.7.2"

[[deps.Pkg]]
deps = ["Artifacts", "Dates", "Downloads", "FileWatching", "LibGit2", "Libdl", "Logging", "Markdown", "Printf", "REPL", "Random", "SHA", "Serialization", "TOML", "Tar", "UUIDs", "p7zip_jll"]
uuid = "44cfe95a-1eb2-52ea-b672-e2afdf69b78f"
version = "1.9.2"

[[deps.PlutoUI]]
deps = ["AbstractPlutoDingetjes", "Base64", "ColorTypes", "Dates", "FixedPointNumbers", "Hyperscript", "HypertextLiteral", "IOCapture", "InteractiveUtils", "JSON", "Logging", "MIMEs", "Markdown", "Random", "Reexport", "URIs", "UUIDs"]
git-tree-sha1 = "e47cd150dbe0443c3a3651bc5b9cbd5576ab75b7"
uuid = "7f904dfe-b85e-4ff6-b463-dae2292396a8"
version = "0.7.52"

[[deps.PrecompileTools]]
deps = ["Preferences"]
git-tree-sha1 = "03b4c25b43cb84cee5c90aa9b5ea0a78fd848d2f"
uuid = "aea7be01-6a6a-4083-8856-8a6e6704d82a"
version = "1.2.0"

[[deps.Preferences]]
deps = ["TOML"]
git-tree-sha1 = "7eb1686b4f04b82f96ed7a4ea5890a4f0c7a09f1"
uuid = "21216c6a-2e73-6563-6e65-726566657250"
version = "1.4.0"

[[deps.Printf]]
deps = ["Unicode"]
uuid = "de0858da-6303-5e67-8744-51eddeeeb8d7"

[[deps.REPL]]
deps = ["InteractiveUtils", "Markdown", "Sockets", "Unicode"]
uuid = "3fa0cd96-eef1-5676-8a61-b3b8758bbffb"

[[deps.Random]]
deps = ["SHA", "Serialization"]
uuid = "9a3f8284-a2c9-5f02-9a11-845980a1fd5c"

[[deps.Reexport]]
git-tree-sha1 = "45e428421666073eab6f2da5c9d310d99bb12f9b"
uuid = "189a3867-3050-52da-a836-e630ba90ab69"
version = "1.2.2"

[[deps.SHA]]
uuid = "ea8e919c-243c-51af-8825-aaa63cd721ce"
version = "0.7.0"

[[deps.Serialization]]
uuid = "9e88b42a-f829-5b0c-bbe9-9e923198166b"

[[deps.SimpleBufferStream]]
git-tree-sha1 = "874e8867b33a00e784c8a7e4b60afe9e037b74e1"
uuid = "777ac1f9-54b0-4bf8-805c-2214025038e7"
version = "1.1.0"

[[deps.Sockets]]
uuid = "6462fe0b-24de-5631-8697-dd941f90decc"

[[deps.SparseArrays]]
deps = ["Libdl", "LinearAlgebra", "Random", "Serialization", "SuiteSparse_jll"]
uuid = "2f01184e-e22b-5df5-ae63-d93ebab69eaf"

[[deps.Statistics]]
deps = ["LinearAlgebra", "SparseArrays"]
uuid = "10745b16-79ce-11e8-11f9-7d13ad32a3b2"
version = "1.9.0"

[[deps.SuiteSparse_jll]]
deps = ["Artifacts", "Libdl", "Pkg", "libblastrampoline_jll"]
uuid = "bea87d4a-7f5b-5778-9afe-8cc45184846c"
version = "5.10.1+6"

[[deps.TOML]]
deps = ["Dates"]
uuid = "fa267f1f-6049-4f14-aa54-33bafae1ed76"
version = "1.0.3"

[[deps.Tar]]
deps = ["ArgTools", "SHA"]
uuid = "a4e569a6-e804-4fa4-b0f3-eef7a1d5b13e"
version = "1.10.0"

[[deps.Test]]
deps = ["InteractiveUtils", "Logging", "Random", "Serialization"]
uuid = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[[deps.TranscodingStreams]]
deps = ["Random", "Test"]
git-tree-sha1 = "9a6ae7ed916312b41236fcef7e0af564ef934769"
uuid = "3bb67fe8-82b1-5028-8e26-92a6c54297fa"
version = "0.9.13"

[[deps.Tricks]]
git-tree-sha1 = "aadb748be58b492045b4f56166b5188aa63ce549"
uuid = "410a4b4d-49e4-4fbc-ab6d-cb71b17b3775"
version = "0.1.7"

[[deps.URIs]]
git-tree-sha1 = "b7a5e99f24892b6824a954199a45e9ffcc1c70f0"
uuid = "5c2747f8-b7ea-4ff2-ba2e-563bfd36b1d4"
version = "1.5.0"

[[deps.UUIDs]]
deps = ["Random", "SHA"]
uuid = "cf7118a7-6976-5b1a-9a39-7adc72f591a4"

[[deps.Unicode]]
uuid = "4ec0a83e-493e-50e2-b9ac-8f72acf5a8f5"

[[deps.Zlib_jll]]
deps = ["Libdl"]
uuid = "83775a58-1f1d-513f-b197-d71354ab007a"
version = "1.2.13+0"

[[deps.libblastrampoline_jll]]
deps = ["Artifacts", "Libdl"]
uuid = "8e850b90-86db-534c-a0d3-1478176c7d93"
version = "5.8.0+0"

[[deps.nghttp2_jll]]
deps = ["Artifacts", "Libdl"]
uuid = "8e850ede-7688-5339-a07c-302acd2aaf8d"
version = "1.48.0+0"

[[deps.p7zip_jll]]
deps = ["Artifacts", "Libdl"]
uuid = "3f19e933-33d8-53b3-aaab-bd5110c3b7a0"
version = "17.4.0+0"
"""

# ╔═╡ Cell order:
# ╠═67019338-dca4-4fe1-8a7c-55cf5b929486
# ╟─5a64e73d-d7b8-4fa3-b81a-3154ae5a122b
# ╟─dc1a4db7-a9fd-49dd-b135-10c7099463b6
# ╟─cfb64224-5ef7-4300-a6e0-f38ad8e68cac
# ╟─ec6b4326-88a1-4375-a828-3e28ca7b2063
# ╟─02124a75-a225-4b7d-9b11-f22c5022a9a5
# ╟─4edc479e-ea0e-4e87-975b-35ac93cc6314
# ╟─ead4250b-1d7b-4934-ba49-2d8aa54dd15e
# ╟─aaafcdbe-a5e4-44da-bb6b-6a2d08c61602
# ╠═7a51fae3-cf99-41d9-834d-add84db94038
# ╟─51f50e0a-e271-4448-b054-4c813dd2f55f
# ╟─6a64ae31-96b9-4eeb-a696-23859c898481
# ╟─f0e96543-bbd5-4095-89e4-e11f510c2d12
# ╟─284d7a22-69b2-4bbb-95c0-c6c7ec32a57f
# ╟─6dca7f64-0e82-4e75-91f3-b72dc85461cf
# ╟─167ee46b-e00f-406a-aa9e-b0d932641611
# ╟─0185a035-5e64-42e8-bec1-91c1aeab460f
# ╠═dad48233-c0ab-475d-9ba9-d7e4038df471
# ╠═a4016cf3-6269-44c3-a1c6-5b513c4c3740
# ╠═3438854f-f0b6-4508-bade-fa17f0bba636
# ╟─62244b7c-adba-463b-9b58-a1359cfcceb8
# ╠═50aba0f6-1cbe-478d-b2db-b0aaf102f31c
# ╠═d36f0906-2be1-400d-8167-616494e371db
# ╠═0a45f36b-1708-4043-a763-29b2ae7b93a0
# ╠═7a279bb7-283b-493c-b263-d15871fd1e6c
# ╟─bf4cc08f-e9ba-460e-bf86-e6e0f064fecb
# ╟─36ce4558-39b7-4c2e-9e78-4f0ecbdfae41
# ╠═03901eec-aa18-48b2-a807-7a7551e6268f
# ╠═a0cdaed9-868c-4619-9ee5-665ee6f69686
# ╠═0ab3c5e9-3767-404b-a361-7f194e740be3
# ╠═2dc076e1-9d5a-4d6f-ad52-78f3c60a5a58
# ╠═b38e185e-c64e-4c26-9e58-c9ad2dec3969
# ╠═e7a3a4f8-90ae-4bc8-b0fa-d5cb9b0ba3f2
# ╠═1c9c20ed-38a4-47bd-a868-e64ff36101cc
# ╠═764b9285-bc9a-4b13-a652-e7646a1320df
# ╠═9cbd6def-d1e9-406e-a6db-5baecc535537
# ╠═5defb84a-0fe2-4972-8dd5-f0430426b4b4
# ╟─41d41291-4334-43c3-b596-a09433cd0018
# ╟─2d963618-f5b5-47f1-85bc-832bbbc29e5b
# ╟─7fc75f1d-d3c4-435d-a6d3-9a9f453e999c
# ╟─e635ce57-29b9-4164-881b-132f41e3b6ba
# ╠═1a1880ca-f9d5-45df-a8c7-65026c990962
# ╟─04ce6f55-1b44-4457-9b2a-f55383e83acd
# ╠═d167a9f6-57e1-4b11-98dd-e4eede5b665d
# ╠═5eb5333e-e4bc-4839-b0dd-1070b37f7994
# ╠═dfb6421a-ac7f-444b-ad5d-061a45e573ac
# ╠═dfce6ede-7cf7-4e1a-9442-bc112e618f95
# ╟─8f5cfec9-5c67-4c72-86f0-1ec62215e924
# ╠═f344e8fa-67cd-411e-9a75-5d5406bb3ff9
# ╠═e2513772-84f0-4bcc-b234-fb30054e1dd5
# ╟─a4d6c456-6820-40d0-afaf-fe4abae93e0e
# ╠═1ec55ebc-5848-40bd-b78f-0dd8afc0ce5b
# ╟─83393a23-3579-4cd4-af61-729c6d018074
# ╠═ad929880-e25e-4f0e-8d51-ec5eda953abe
# ╠═b81e2c42-8b7e-4487-8c76-d35d023c2a13
# ╟─fad5f0b9-da41-4123-bb91-51500a57dea5
# ╠═708409ac-1f07-481d-ac95-2f028b6d5e80
# ╠═4ad0d0de-7e57-46cc-b9a4-9b07802d997c
# ╠═1354e9d3-206c-4355-9641-45bf3cd179ff
# ╠═69585cb2-a403-49bf-b0d8-36eb347bfaeb
# ╠═c6567c1b-00fc-4c35-81a1-1b92545ad749
# ╠═5702cfab-7d96-482b-8c5a-cf35c045e18c
# ╠═2f8b1912-1cf9-4ef7-95e3-0e795f89c271
# ╟─f7113d25-6b70-495c-a04d-0e984fdda75a
# ╠═0d40730c-2b65-4ef9-86bf-38a80f36e999
# ╠═0d5704c1-932d-429c-b983-22dcfb9dc2b0
# ╠═b8c1a101-2ce0-4fcc-b483-e9a94256355a
# ╠═203ba3c8-5d20-4c2c-998d-99ed25b77bfa
# ╟─39b7138b-e0ac-4512-951e-f3da0596aae9
# ╠═4e6c71be-0777-4994-b46f-2e8ad85dd00f
# ╠═380893cf-d028-49a0-8541-0c375b2d9b6f
# ╠═62f4f0c5-5dd4-4f57-85ae-c5e5eb02a5bc
# ╠═23015434-367f-468d-92e8-c6ba22830d67
# ╠═30a728de-27e5-43f8-999d-c450e941ef2b
# ╟─35fbe418-4bd5-4dee-a98d-9e976a8cb3d9
# ╟─292223b0-0549-47d5-9c13-55e4bca029e2
# ╠═379db06c-a811-4894-9414-4ebeefa90b11
# ╠═75b9042b-d15a-43fe-8651-f5ef2ea083a0
# ╠═f699b11c-6d47-4c18-9fef-3136467a090c
# ╠═8acfc20e-2d57-4cc6-a24e-42fa8acf012a
# ╠═5839e72e-8771-4184-a065-2196ba60b2f4
# ╠═0b6940b5-9d5e-439d-a974-fa056ee1ad2e
# ╠═4e8df286-dfb2-4693-9261-64a9bcc9d002
# ╟─7019a3b5-f0cb-40fa-8e66-51055af971e8
# ╟─4e544be5-4a04-4182-a58e-13bdcd6c517e
# ╠═b1d9c45b-3a31-4029-895c-427d44d44d40
# ╠═f12ade36-ff61-435b-9a76-e9f739fe79ce
# ╟─d5b8e5de-f040-408c-92ac-aed3c3dffe51
# ╠═28a8e5e5-d904-4888-b36b-13c0aad8f3a1
# ╠═3540f431-7b50-4ed1-9d66-3cb4568856a2
# ╟─5912b3ca-a74b-4174-859c-ed5b4cd669d5
# ╠═d74a2fae-422d-4f9d-be03-d438535e2a70
# ╠═e31f1c0c-a914-432e-b20a-6cee84852400
# ╠═f92faad9-15f5-4a2a-951d-42a4b2744e4e
# ╠═cc6f8d8b-fa94-418c-9b1b-11d517e5bb8c
# ╠═c0764726-337c-4c9c-b0bc-235cca726051
# ╟─27e2d30c-96bb-4a28-ba47-6ea7d9bb3b2d
# ╠═88e526c6-cd09-4a75-9bc0-cec5a7a80234
# ╠═a89c40a4-4d12-4fc5-8cb9-75a8e2c9f708
# ╠═ff6530fa-8b79-4321-bde4-d42f3de138c5
# ╠═a779ef7b-f4ff-4d01-9f69-6e04d4e224a9
# ╟─439256c1-652c-4296-86b0-9cf3f810f9f6
# ╟─d304524f-a6d8-4fe3-9a0c-aa55965f831f
# ╠═b21dedc7-23a2-4e79-84fc-943dd3053fab
# ╠═edd18731-64ee-4924-925f-c723ed9ab7ec
# ╠═718f6f4a-f337-4cb3-a9f1-e90a32411d8e
# ╠═a055cb83-9e64-415a-bd1a-cfa4a2b5b7dc
# ╟─8e01e846-b392-4610-8be1-e15485a74eaf
# ╠═0a4a689d-5a4e-4d5e-a278-beb137a80ac6
# ╠═18cae4b0-0b2a-407a-b8c6-236a631a84a7
# ╟─a1d25013-d982-438b-a9be-cb8f2a651a8a
# ╠═e442bb4c-4470-4415-9247-caffda420bf5
# ╠═7be99f73-40bf-4717-b64b-b4b0e850c364
# ╟─4ba402a6-2fbe-493d-8de8-266eace85a35
# ╠═17e4686d-f9a0-4201-baec-4cc1730b1821
# ╠═7d20bf88-7f1f-4159-88b3-c40d2e671781
# ╠═9fa94e04-fdbb-4f05-af6b-9330b3f52ec4
# ╠═57a03ff9-6fa0-457c-88d4-898a6fde710c
# ╟─1f03b743-60c7-45e1-bba0-1f008697a03e
# ╠═1260013b-da66-439a-9a2b-76ccb7b4a132
# ╠═065f15ad-1cbe-474e-901f-411aefb2e07f
# ╠═6fa90f17-74c4-4ee7-9f1d-ac317c36100d
# ╟─cfab338f-19b1-4a26-b74c-ee630f4a3769
# ╠═269d7cff-d99e-4eb9-a573-c08b869463e7
# ╠═33103b72-5f3b-4699-9649-9204361ee9d7
# ╠═6cc5ec16-ff84-44c6-a704-d3ab92b49cc1
# ╠═dd807cf4-15cd-4d8f-816d-ffeb259953ae
# ╠═5ccba59a-fec6-429e-8bf2-0445819ba1d2
# ╟─3764bd78-069b-4c9d-bcbe-12f85da65d9c
# ╠═9076e90c-472b-40a7-9399-61f61ca893ac
# ╠═ddb07406-e982-4829-9297-ed1427234ed0
# ╠═f0868cfc-336a-403d-88b3-d6c0ad4b31f1
# ╟─d3b4eb44-ff14-424d-b97c-53fc373ae03d
# ╠═4803a865-00ad-4595-8d05-43aef456e398
# ╠═4ac509b2-61ca-401a-83db-9298537de7e1
# ╟─5f70b1ed-6f99-4997-aa37-0efd6b1b6249
# ╠═a386ef9e-674a-4d7a-8f55-6603070457c3
# ╟─8d091301-85e9-46d5-a4ae-1aac98f1fedd
# ╠═ba6b772c-5691-4e48-8f37-972956cdee65
# ╠═c05d7186-3761-4d86-be54-ccd0c8c58b5a
# ╠═dbace4f9-e018-4356-8ed3-e652c7f123b4
# ╟─cd2211ae-5864-4e87-9293-3b4c81ef23b2
# ╟─524df39e-8200-4a53-b762-5558e7a1a527
# ╠═7fa1ca91-8c28-4a02-8d91-79e23decf30c
# ╠═bab0698a-7ec1-4e37-a9b1-c66746062e3e
# ╠═a855e0ec-cb0f-49c8-a9de-fa0e72b1f8ea
# ╠═58a47ef9-3f48-46a3-a0c2-e2030e9d6cbe
# ╠═b3afedf1-ec7b-4c7f-a9fd-d110e319cd91
# ╠═1ae9fe95-4028-4ad9-8bea-9e70038d97aa
# ╠═83cdb063-631d-4665-99f7-160485675b15
# ╟─d2bc4dba-f8af-49ed-bede-a4b5a4b0d63c
# ╠═3f8f066b-8d6c-4503-9223-66a03f3c92cc
# ╠═bdff1fdf-1fb9-4efe-95a8-cfe84b4d1b5c
# ╠═308270ba-883a-42a6-98ef-84ace09f581f
# ╟─0243070a-ee48-4909-b14e-dfcd770490f2
# ╠═80208609-848e-4126-9728-3a4e96073209
# ╠═d168ee9a-d869-446b-9de7-cd8c5feaf52c
# ╠═aeb2f9dc-9337-4417-b6fe-56b89b4e3553
# ╟─0e8b63aa-60aa-4624-99fc-3201e9ccd0be
# ╠═19cb9bbc-0d03-4aab-9817-8c44c1467f1c
# ╠═2fb307cf-3c4c-4496-9d28-6d00045f9a0e
# ╠═ee209254-aaaa-47bc-8742-66b41f5cc1cb
# ╠═cc1de85e-004f-4dfa-a470-3cb4fc44ccb9
# ╠═f8789abc-2109-4933-b601-a364d4632abb
# ╠═f17023ef-d835-445d-ba18-bfd5872f0764
# ╠═3c64486c-4aab-40f4-8fd5-2cfbb74cf856
# ╠═ee70a87a-4a0f-49b6-83f9-eaa421300682
# ╠═753dd774-bc71-40a6-866e-99167ec5a635
# ╠═b4f5295a-71a1-45a1-b840-465b97dfa35f
# ╠═bde035e5-8e89-4f57-82d3-cf4a3538cb62
# ╟─f5910485-4831-4fec-b7c6-dde8da9ea4c4
# ╟─f434ec9b-f21f-4b13-a2b3-0d1fb3249e1c
# ╠═465a6a3d-51fa-438d-99cd-d4225e69f891
# ╠═da814e35-d7bb-4bb7-880a-1200de12680a
# ╟─45a9bbc8-fd43-46c9-b4bb-f0ce8a0cf7cd
# ╠═9f143610-c2ac-419a-94c5-aeb832eab25a
# ╠═b8481b81-e60a-460a-bdd2-ad843825c974
# ╠═bff39067-4254-4759-ba96-c39fdb21dbc7
# ╠═ab60a221-31ac-4f22-9949-ffcef1bf33bc
# ╟─c5b7f19b-1d06-4c30-b9d6-700e6d8cb95b
# ╟─f7f76395-39d5-49d7-a9b9-f10d232f46bf
# ╟─05b2f5c1-cecc-4815-ad4c-87bce0b103ca
# ╠═8b049907-5266-4066-84db-271b747996d7
# ╠═867b78a8-1183-41b3-ad1c-a0d6db7dc075
# ╠═0edff351-2fc8-4759-b2ad-fb5c447119d2
# ╠═f5a96665-ee82-4aec-8db8-59ec603276be
# ╟─ba31c664-e23f-487d-826f-e259a2b2ccbd
# ╠═c3887ca1-3727-4121-a93d-4fea9fa55e9d
# ╠═6a25736a-190e-4f7a-8625-b4bd10e9c463
# ╟─d31c6d68-7929-4420-a3fb-1b4e9f6d2fc4
# ╠═794b30c9-c990-41f6-81e3-9bdae57bffcc
# ╠═58eb6102-a11e-419b-a6a2-ce1d38621203
# ╟─cbd27fc4-ba4e-43b3-8783-6d1bade31447
# ╠═281165a4-036e-42c7-bf85-2beab7626fbc
# ╠═bbb0e8bf-ea62-4620-837f-74e9b84b2529
# ╠═a5009256-8294-4596-b5d0-b6ada1d32c9e
# ╠═5ef3aa75-2411-420f-b27a-ee8d792c2455
# ╠═74cf7b29-05e1-4469-9d64-cadcccdf5cf6
# ╠═94a3cd24-9221-4f12-9112-ef2117edd009
# ╟─5ca71a2a-b7c5-494a-b7e4-25dc4b0a11fa
# ╠═b5c18a8d-e20c-4a8f-983d-746a20ee41d4
# ╠═21c58017-2d2c-4abd-b7f4-e05fcbd0a936
# ╠═49ec27d1-72ec-4e50-b38e-bef8941e5522
# ╠═92977747-cbc3-41e5-ba86-a8f1bb547a4c
# ╠═8b9e2b3b-4654-40bd-9304-2ac8f520a2b7
# ╠═46662d36-c690-4bb4-998a-6d6ac9b33a51
# ╟─8ca24420-966f-45a5-86f6-ac21b999006e
# ╠═53238993-9668-4412-8d6e-c24bcc3518f3
# ╠═c4d18d69-a8a1-4dd5-862a-4dc4d9a5db44
# ╠═ffc4b3ae-f6d3-4b66-a323-61e256fac24f
# ╠═cef4db28-eea2-4c3f-8a35-71a01f4a3297
# ╟─5560ec19-78a4-4c1d-accd-9c07c29c0e18
# ╟─1c7fbed3-6035-48b9-94ac-2b50086a6a12
# ╟─c18f82cb-f7b3-4f03-b387-b17745e11597
# ╟─2dd38b7f-1310-460e-996d-61f104dbfa7d
# ╟─f4bde725-a4c4-4822-b4db-cd66a21e9944
# ╟─974d0237-4e0d-4abc-a52c-649813b6290e
# ╠═fd358455-35a1-42d1-bf67-e6b201ad37f2
# ╠═03f1bd8c-5eec-41c4-b0bf-4bdabed6319f
# ╟─9f65d099-dda1-4c13-b41d-e1c45cc8410c
# ╠═e56fb773-68dd-4b1c-b98a-575aea4d1a83
# ╟─0edb4a14-21f8-462b-8d42-ce95f45aebc3
# ╟─a82faf94-ebc6-4f64-9110-cfae5d478c40
# ╠═0233e78f-f8cd-449c-9a07-4a4c2bb22bdc
# ╟─ba414c29-470a-49c5-996a-917984bc9f91
# ╟─42a8ee30-8f6a-4805-a196-1f50bd1be76e
# ╠═60d842e5-42c4-46ab-aa2d-0aff5ad559e9
# ╟─eeb589d3-ef08-45e6-96d0-e8a43990f355
# ╟─44f60c42-a622-46a7-9b13-334bc7f2b1a4
# ╠═a36cc9c3-e097-4093-b9dc-29821c60e251
# ╟─c4da3c06-2269-4b56-8f0c-c797d4195e5b
# ╟─5d23e533-861d-4501-ac66-da666f0ef4e3
# ╠═84d5071e-2b91-4341-8839-0352172afb7d
# ╟─2e677cda-c26f-445f-8f18-a7b1e55180b8
# ╟─c247f64b-457a-4bb7-88dd-a9d2ecc3ae0e
# ╠═e6181b7f-d65a-4ce0-b12a-cb76169cb0f6
# ╟─212cf3bc-a0b2-4f8d-bb51-5e6104d17287
# ╟─602ea0fd-eb5c-4129-9987-02bf23074292
# ╟─9ea456f7-0e60-44d5-8e5a-1ad3efe71996
# ╟─40d31e37-ad99-44c3-98e6-494b07d42d66
# ╠═5bc53b65-b68d-4d55-b74e-874b27c332dc
# ╠═1493f40e-1b5c-4cb3-a606-393beee8c0b5
# ╟─11a3dd19-92ce-48c1-ae23-4b36a3a5e333
# ╟─a13a3943-3189-4ec5-be1e-1eabf1462118
# ╠═f54e0a94-b6f2-4fe4-8c59-d4fbbb27c727
# ╠═a3e15840-ec8d-4d13-802f-018d665086f2
# ╟─2102c883-4c2f-461b-bfea-5421c9bfcae8
# ╟─14498fbd-eb00-4291-990a-4583bd008587
# ╠═ebd59160-9185-4837-bec6-cdd4c4a9acc3
# ╠═847d06b7-826c-4aea-9074-69182ec78871
# ╠═032ecfce-4068-423e-ad16-dc007881af26
# ╠═f013daac-f334-400e-b6f2-d7ebc95d02b4
# ╟─e8c1a367-e3f3-4b0d-a0f9-2aa6a80b1123
# ╟─fa8f6be1-2429-499c-ac43-022a341bb71f
# ╠═4cf0696e-e821-471e-96df-1f6237008e9d
# ╠═be9a3bb9-7ae6-465c-ac37-5f239d7aa49e
# ╟─dacd9f4a-924d-4cd3-a2d4-5a5753d2335e
# ╠═1aef68dd-ed5a-4c0c-aa02-d1fc956f7f24
# ╠═7926b299-ba82-4ce1-ae1b-077e4150f71c
# ╠═31c0e9d3-e4a3-4f9d-80f2-22e4cbd70ca8
# ╟─ce26d829-a7de-4194-96ef-9a81732db012
# ╟─9603700b-cd87-4873-b452-0fd0a9395c76
# ╟─1a1ec8e6-87f4-4ecd-82c9-141949b5c061
# ╠═86d11ad1-4842-4bdf-9e46-92ef48c3d9ef
# ╠═5a15f415-2959-4b80-ba2d-bf3edaf1f193
# ╠═6f386ffe-d3ec-40a9-80e7-30c8e4625fb5
# ╠═aa9f08f4-c5bc-4312-aa2d-545069969c38
# ╟─ab0b7723-6c28-4616-af5f-1e67b62fb03a
# ╠═6276c42a-af0e-4277-8dc3-746f7466c010
# ╠═b7433a36-3b91-4dcc-9cc8-bd2ea996f0b5
# ╟─d851527a-d303-4870-b4a4-b393b138d2c2
# ╠═bd574d52-e848-4a5a-a3b2-6b5e2264ceb5
# ╠═9813645e-5070-4be6-afe3-66ced0456c22
# ╟─9db85a08-3b02-4e12-ac20-d5e6e10addcb
# ╠═355c0db5-ddfc-4af2-8902-1bcf0cacfb97
# ╟─aa9b6d9c-2999-4a48-8fd5-b3d94d1b3a68
# ╟─e4505a13-2039-47e1-aa88-9eaa230013de
# ╠═3cb96773-fac7-493a-b374-ecca5eb2c3a8
# ╠═15ddb8f6-a00a-45ec-a8cb-fa7add86f2f1
# ╠═ec5c39ef-2641-4029-9abf-98eee3fe767e
# ╠═0842a2f8-a087-447b-929d-e59c60d9d8d0
# ╟─66d2514c-7deb-4f93-bc19-318812a9da2d
# ╠═b1c32cd1-da0b-45fb-ad89-681b76d9df43
# ╟─46c158c3-ab1b-43aa-9eb0-dd2a47b8406a
# ╟─5030ce0e-9d61-455c-8203-c6bfa4731a95
# ╟─0042e8a0-61be-4768-ae31-0445d531e5ff
# ╠═3e5074ba-9b55-417f-99b8-b1ff3796c969
# ╟─6900f9dc-1655-458a-8592-cb25c4319b92
# ╠═30f934d3-9ece-43df-9f12-bbe2805a4120
# ╟─5703fed8-0c25-4a94-a70a-626f90817cd0
# ╠═0b66c477-02be-44f8-ad85-a44824c3d24f
# ╠═d32932e7-a200-4833-962c-aa1de136598d
# ╠═5f555381-cf5c-4122-957f-f01f5dca8cf1
# ╠═b9838c1d-9a89-4529-8c91-60a1f03eb503
# ╠═693010e2-de30-4902-b24e-a5a3fdf15737
# ╠═6cb35f5f-20dd-4c44-9843-3687d847882d
# ╟─76e9e262-0599-4e9f-9a49-1a223602cfec
# ╠═99f1f97b-d6cd-4d7b-a41f-73ae9c1786ce
# ╟─57f0cdb1-b4d0-45c3-97a1-59f42c369df9
# ╠═14f0ed67-7a2c-4ed1-9630-163d95de5bae
# ╠═818fab0d-f4ae-41cd-a00f-874e3ef8aa54
# ╟─00000000-0000-0000-0000-000000000001
# ╟─00000000-0000-0000-0000-000000000002
